const SECONDS_PER_YEAR = 31536000;

// Chain ID to Chain Name mapping
const CHAIN_ID_TO_NAME: Record<number, string> = {
  1: "ETH",
  42161: "ARB",
  56: "BSC"
};

const SIMILAR_TOKENS_AND_CURRENY: Record<string, string> = {
  "0xETH": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "0xARBETH": "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
  "0x": "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c"
};

const SUPPORTED_TOKENS_TO_MARKETS: Record<
  string,
  { chainId: number; market: string }
> = {
  // ETH
  "0xETH": { chainId: 1, market: "ETH" },
  "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48": { chainId: 1, market: "USDC" },
  "0xdac17f958d2ee523a2206206994597c13d831ec7": { chainId: 1, market: "USDT" },
  "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2": { chainId: 1, market: "WETH" },
  // FLUID
  "0x40d16fc0246ad3160ccc09b8d0d3a2cd28ae6c2f": { chainId: 1, market: "GHO" },
  "0xc139190f447e929f090edeb554d95abb8b18ac1c": { chainId: 1, market: "USDTB" },
  "0xa3931d71877c0e7a3148cb7eb4463524fec27fbd": { chainId: 1, market: "SUSDS" },
  "0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0": { chainId: 1, market: "WSTETH" },
  // FLUID

  // 'ethWBNB': { chainId: 1, market: 'WBNB' },
  "0x6b175474e89094c44da98b954eedeac495271d0f": { chainId: 1, market: "DAI" },

  // ARB
  "0xARBETH": { chainId: 42161, market: "ETH" },
  "0xaf88d065e77c8cc2239327c5edb3a432268e5831": {
    chainId: 42161,
    market: "USDC"
  },
  "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9": {
    chainId: 42161,
    market: "USDT"
  },
  "0x82af49447d8a07e3bd95bd0d56f35241523fbab1": {
    chainId: 42161,
    market: "WETH"
  },
  // FLUID
  "0x7dff72693f6a4149b17e7c6314655f6a9f7c8b33": { chainId: 42161, market: "GHO" },
  "0x912ce59144191c1204e64559fe8253a0e49e6548": { chainId: 42161, market: "ARB" },
  "0xddb46999f8891663a8f2828d25298f70416d7610": { chainId: 42161, market: "SUSDS" },
  "0x5979d7b546e38e414f7e9822514be443a4800529": { chainId: 42161, market: "WSTETH" },
  // FLUID

  // 'arbWBNB': { chainId: 42161, market: 'WBNB' },
  "0xda10009cbd5d07dd0cecc66161fc93d7c9000da1": {
    chainId: 42161,
    market: "DAI"
  },

  // BSC
  "0xBNB": { chainId: 56, market: "BNB" },
  "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d": { chainId: 56, market: "USDC" },
  "0x55d398326f99059ff775485246999027b3197955": { chainId: 56, market: "USDT" },
  // 'bscWETH': { chainId: 56, market: 'WETH' },
  "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c": { chainId: 56, market: "WBNB" },
  "0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3": { chainId: 56, market: "DAI" }
};

const RPC_URLS: Record<number, string> = {
  // 1: "https://eth.rpc.blxrbdn.com", //"https://eth.llamarpc.com",
  1: "https://eth-mainnet.public.blastapi.io",
  42161: "https://arb1.arbitrum.io/rpc",
  56: "https://bsc-rpc.publicnode.com"
};
const API_URLS: Record<number, { apiUrl: string; apiKey: string }> = {
  1: {
    apiUrl: "https://api.etherscan.io/v2/api",
    apiKey: "CWPKD9ENEAFCFSJBUBMCFHX86EPNM99EAD"
  },
  42161: {
    apiUrl: "https://api.etherscan.io/v2/api",
    apiKey: "CWPKD9ENEAFCFSJBUBMCFHX86EPNM99EAD"
  },
  56: {
    apiUrl: "https://api.etherscan.io/v2/api",
    apiKey: "CWPKD9ENEAFCFSJBUBMCFHX86EPNM99EAD"
  }
};

const WALLET_ADDRESS = "0x5fbc2F7B45155CbE713EAa9133Dd0e88D74126f6";

export {
  SECONDS_PER_YEAR,
  CHAIN_ID_TO_NAME,
  SIMILAR_TOKENS_AND_CURRENY,
  SUPPORTED_TOKENS_TO_MARKETS,
  RPC_URLS,
  API_URLS,
  WALLET_ADDRESS
};

export const protocols = [
{
  "_id": {
    "$oid": "68bab201a7e2c8ebb80450de"
  },
  "name": "Maple",
  "website": "https://maple.finance/",
  "image": "/protocols/maple-1757065729245-99531850.jpg"
},
{
  "_id": {
    "$oid": "68be81d22c43be53109d0682"
  },
  "name": "Sparklend",
  "website": "https://spark.fi/",
  "image": "/protocols/maple-1757315538730-703170841.jpg"
},
{
  "_id": {
    "$oid": "68beaee36f8a85b3ca5080a4"
  },
  "name": "Euler",
  "website": "https://www.euler.finance/",
  "image": "/protocols/maple-1757327075651-864017173.jpg"
},
{
  "_id": {
    "$oid": "68bff270e8bb7a6698ff82a5"
  },
  "name": "Cream Finance",
  "website": "https://docs.cream.finance/",
  "image": "/protocols/maple-1757409904043-961055872.jpg"
},
{
  "_id": {
    "$oid": "68c26285eaecfa1701077e89"
  },
  "name": "Ethena",
  "website": "https://ethena.fi/",
  "image": "/protocols/bnb-logo-1757569669666-232127135.png"
},
{
  "_id": {
    "$oid": "68c26839eaecfa1701077e8c"
  },
  "name": "Kinza Finance",
  "website": "https://kinza.finance/",
  "image": "/protocols/bnb-logo-1757571129454-853211391.png"
},
{
  "_id": {
    "$oid": "68c2bf3c416be2831e43f870"
  },
  "name": "Zerolend",
  "website": "https://zerolend.xyz/",
  "image": "/protocols/eth-logo-1757593404413-336068420.png"
},
{
  "_id": {
    "$oid": "68c3cfbf8f07c736ffcad23e"
  },
  "name": "Dolomite",
  "website": "https://docs.dolomite.io/",
  "image": "/protocols/eth-logo-1757663167107-33929004.png"
},
{
  "_id": {
    "$oid": "68c412ced0b63e39e3bd2904"
  },
  "name": "Flux Finance",
  "website": "https://fluxfinance.com/",
  "image": "/protocols/usdc-logo-1757680334631-162255223.png"
},
{
  "_id": {
    "$oid": "68c7b648a18ab4e604db8f34"
  },
  "name": "Yearn V3",
  "website": "https://docs.yearn.fi/",
  "image": "/protocols/usdt-logo-1757918792162-682045866.png"
},
{
  "_id": {
    "$oid": "68cbb6f89892471ecbaeaf44"
  },
  "name": "Illuvium",
  "website": "https://illuvium.io/",
  "image": "/protocols/usdc-logo-1758181112682-770729321.png"
},
{
  "_id": {
    "$oid": "68cbe617d56874f9edd20815"
  },
  "name": "WINR",
  "website": "https://winr.games/",
  "image": "/protocols/dai-logo-1758193175792-963693950.png"
}]

export const definitions = [{
  "_id": {
    "$oid": "68af078bf48122df91aa93b3"
  },
  "asset": {
    "$oid": "68af071df48122df91aa93b1"
  },
  "protocol": {
    "$oid": "68af0724f48122df91aa93b2"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d\";\n  const rpcUrl = \"https://bsc.drpc.org\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x6807dc923806fE8Fd134338EABCA509979a7e0cB\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[2];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d\"\n    const marketAddress = \"0x6807dc923806fE8Fd134338EABCA509979a7e0cB\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d\"\n    const rpcUrl = \"https://bsc.drpc.org\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0x6807dc923806fE8Fd134338EABCA509979a7e0cB\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d",
  "withdrawContract": "",
  "withdrawUri": "",
  "yieldBearingToken": "0x00901a076785e0906d1028c7d6372d247bec7d61"
},
{
  "_id": {
    "$oid": "68b0279fc849df1b70af1977"
  },
  "asset": {
    "$oid": "68b0218cc849df1b70af195c"
  },
  "protocol": {
    "$oid": "68af0724f48122df91aa93b2"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\";\n  const rpcUrl = \"https://bsc.drpc.org\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x6807dc923806fE8Fd134338EABCA509979a7e0cB\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[2];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0x0c2C95b24529664fE55D4437D7A31175CFE6c4f7\";\n    const marketAddress = \"0x6807dc923806fE8Fd134338EABCA509979a7e0cB\"\n\n    const aaveV3WithdrawABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            name: \"withdrawETH\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdrawETH\",\n            args: [marketAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0x0c2C95b24529664fE55D4437D7A31175CFE6c4f7\";\n    const marketAddress = \"0x6807dc923806fE8Fd134338EABCA509979a7e0cB\"\n\n    const aaveV3DepositABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"depositETH\",\n            stateMutability: \"payable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: aaveV3DepositABI,\n            functionName: \"depositETH\",\n            args: [marketAddress, address, 0],\n            value: amountInWei,\n            chainId\n        });\n        success = true; // Already approved\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "",
  "withdrawContract": "",
  "withdrawUri": "",
  "yieldBearingToken": "0x9B00a09492a626678E5A3009982191586C444Df9"
},
{
  "_id": {
    "$oid": "68b034c9e0d13595b429a254"
  },
  "asset": {
    "$oid": "68b0349ae0d13595b429a253"
  },
  "protocol": {
    "$oid": "68af0724f48122df91aa93b2"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\";\n  const rpcUrl = \"https://bsc.drpc.org\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x6807dc923806fE8Fd134338EABCA509979a7e0cB\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[2];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\"\n    const marketAddress = \"0x6807dc923806fE8Fd134338EABCA509979a7e0cB\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\"\n    const rpcUrl = \"https://bsc.drpc.org\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0x6807dc923806fE8Fd134338EABCA509979a7e0cB\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
  "withdrawContract": "",
  "withdrawUri": "",
  "yieldBearingToken": "0x9B00a09492a626678E5A3009982191586C444Df9"
},
{
  "_id": {
    "$oid": "68b6b9498003ed8289661e82"
  },
  "asset": {
    "$oid": "68b14ac3f55db3d0dfa7df53"
  },
  "protocol": {
    "$oid": "68af0724f48122df91aa93b2"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0x55d398326f99059ff775485246999027b3197955\";\n  const rpcUrl = \"https://bsc.drpc.org\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x6807dc923806fE8Fd134338EABCA509979a7e0cB\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[2];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0x55d398326f99059ff775485246999027b3197955\"\n    const marketAddress = \"0x6807dc923806fE8Fd134338EABCA509979a7e0cB\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0x55d398326f99059ff775485246999027b3197955\"\n    const rpcUrl = \"https://bsc.drpc.org\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0x6807dc923806fE8Fd134338EABCA509979a7e0cB\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0x55d398326f99059ff775485246999027b3197955",
  "yieldBearingToken": "0xa9251ca9DE909CB71783723713B21E4233fbf1B1",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6bb8f8003ed828966205b"
  },
  "asset": {
    "$oid": "68b14b46f55db3d0dfa7df5d"
  },
  "protocol": {
    "$oid": "68af0724f48122df91aa93b2"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";\n  const rpcUrl = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[2];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0xd01607c3C5eCABa394D8be377a08590149325722\";\n    const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\"\n\n    const aaveV3WithdrawABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            name: \"withdrawETH\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdrawETH\",\n            args: [marketAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0xd01607c3C5eCABa394D8be377a08590149325722\";\n    const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\"\n\n    const aaveV3DepositABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"depositETH\",\n            stateMutability: \"payable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: aaveV3DepositABI,\n            functionName: \"depositETH\",\n            args: [marketAddress, address, 0],\n            value: amountInWei,\n            chainId\n        });\n        success = true; // Already approved\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "",
  "yieldBearingToken": "0x4d5F47FA6A74757f35C14fD3a6Ef8E3C9BC514E8",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6bbb58003ed828966207f"
  },
  "asset": {
    "$oid": "68b14c85f55db3d0dfa7df6f"
  },
  "protocol": {
    "$oid": "68af0724f48122df91aa93b2"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";\n  const rpcUrl = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[2];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"\n    const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"\n    const rpcUrl = \"https://eth.rpc.blxrbdn.com\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "yieldBearingToken": "0x4d5F47FA6A74757f35C14fD3a6Ef8E3C9BC514E8",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6c24573e4513a33a46278"
  },
  "asset": {
    "$oid": "68b14b6bf55db3d0dfa7df5e"
  },
  "protocol": {
    "$oid": "68af0724f48122df91aa93b2"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\";\n  const rpcUrl = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[2];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\"\n    const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\"\n    const rpcUrl = \"https://eth.rpc.blxrbdn.com\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  "yieldBearingToken": "0x98C23E9d8f34FEFb1B7BD6a91B7FF122F4e16F5c",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6c28a73e4513a33a462db"
  },
  "asset": {
    "$oid": "68b14b85f55db3d0dfa7df62"
  },
  "protocol": {
    "$oid": "68af0724f48122df91aa93b2"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0xdac17f958d2ee523a2206206994597c13d831ec7\";\n  const rpcUrl = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[2];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xdac17f958d2ee523a2206206994597c13d831ec7\"\n    const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xdac17f958d2ee523a2206206994597c13d831ec7\"\n    const rpcUrl = \"https://eth.rpc.blxrbdn.com\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0xdac17f958d2ee523a2206206994597c13d831ec7",
  "yieldBearingToken": "0x23878914EFE38d27C4D67Ab83ed1b93A74D4086a",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6c2d573e4513a33a46354"
  },
  "asset": {
    "$oid": "68b14c95f55db3d0dfa7df70"
  },
  "protocol": {
    "$oid": "68af0724f48122df91aa93b2"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0x6b175474e89094c44da98b954eedeac495271d0f\";\n  const rpcUrl = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[2];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0x6b175474e89094c44da98b954eedeac495271d0f\"\n    const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0x6b175474e89094c44da98b954eedeac495271d0f\"\n    const rpcUrl = \"https://eth.rpc.blxrbdn.com\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0x6b175474e89094c44da98b954eedeac495271d0f",
  "yieldBearingToken": "0x018008bfb33d285247A21d44E50697654f754e63",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6c37b73e4513a33a4647e"
  },
  "asset": {
    "$oid": "68b14caff55db3d0dfa7df74"
  },
  "protocol": {
    "$oid": "68af0724f48122df91aa93b2"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0x82af49447d8a07e3bd95bd0d56f35241523fbab1\";\n  const rpcUrl = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\";\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n    const liquidityRate = reserveData[2];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0x5283BEcEd7ADF6D003225C13896E536f2D4264FF\";\n    const marketAddress = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\"\n\n    const aaveV3WithdrawABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            name: \"withdrawETH\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdrawETH\",\n            args: [marketAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0x5283BEcEd7ADF6D003225C13896E536f2D4264FF\";\n    const marketAddress = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\"\n\n    const aaveV3DepositABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"depositETH\",\n            stateMutability: \"payable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: aaveV3DepositABI,\n            functionName: \"depositETH\",\n            args: [marketAddress, address, 0],\n            value: amountInWei,\n            chainId\n        });\n        success = true; // Already approved\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "",
  "yieldBearingToken": "0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6c3c073e4513a33a4650b"
  },
  "asset": {
    "$oid": "68b14cd8f55db3d0dfa7df75"
  },
  "protocol": {
    "$oid": "68af0724f48122df91aa93b2"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0xaf88d065e77c8cc2239327c5edb3a432268e5831\";\n  const rpcUrl = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[2];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xaf88d065e77c8cc2239327c5edb3a432268e5831\"\n    const marketAddress = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xaf88d065e77c8cc2239327c5edb3a432268e5831\"\n    const rpcUrl = \"https://arb1.arbitrum.io/rpc\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0xaf88d065e77c8cc2239327c5edb3a432268e5831",
  "yieldBearingToken": "0x724dc807b04555b71ed48a6896b6F41593b8C637",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6c40473e4513a33a4659b"
  },
  "asset": {
    "$oid": "68b14ce5f55db3d0dfa7df79"
  },
  "protocol": {
    "$oid": "68af0724f48122df91aa93b2"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\";\n  const rpcUrl = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[2];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\"\n    const marketAddress = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\"\n    const rpcUrl = \"https://arb1.arbitrum.io/rpc\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
  "yieldBearingToken": "0x6ab707Aca953eDAeFBc4fD23bA73294241490620",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6c4e873e4513a33a467d7"
  },
  "asset": {
    "$oid": "68b14d05f55db3d0dfa7df7b"
  },
  "protocol": {
    "$oid": "68af0724f48122df91aa93b2"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0xda10009cbd5d07dd0cecc66161fc93d7c9000da1\";\n  const rpcUrl = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[2];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xda10009cbd5d07dd0cecc66161fc93d7c9000da1\"\n    const marketAddress = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xda10009cbd5d07dd0cecc66161fc93d7c9000da1\"\n    const rpcUrl = \"https://arb1.arbitrum.io/rpc\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0xda10009cbd5d07dd0cecc66161fc93d7c9000da1",
  "yieldBearingToken": "0x82E64f49Ed5EC1bC6e43DAD4FC8Af9bb3A2312EE",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6ce5c30d28f1784f33355"
  },
  "asset": {
    "$oid": "68b14b46f55db3d0dfa7df5d"
  },
  "protocol": {
    "$oid": "68b00cf8c849df1b70af1903"
  },
  "apy": "(async function (ethers) {\n    const tokenAddress = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";\n    const rpcUrl = \"https://eth.rpc.blxrbdn.com\";\n    const provider = new ethers.JsonRpcProvider(rpcUrl);\n    const marketAddress = \"0xA950974f64aA33f27F6C5e017eEE93BF7588ED07\";\n\n    const aaveABI = [\n        {\n            inputs: [{ name: \"asset\", type: \"address\" }],\n            name: \"getReserveData\",\n            outputs: [\n                { name: \"availableLiquidity\", type: \"uint256\" },\n                { name: \"totalStableDebt\", type: \"uint256\" },\n                { name: \"totalVariableDebt\", type: \"uint256\" },\n                { name: \"liquidityRate\", type: \"uint256\" },\n                { name: \"variableBorrowRate\", type: \"uint256\" },\n                { name: \"stableBorrowRate\", type: \"uint256\" },\n                { name: \"averageStableBorrowRate\", type: \"uint256\" },\n                { name: \"liquidityIndex\", type: \"uint256\" },\n                { name: \"variableBorrowIndex\", type: \"uint256\" },\n                { name: \"lastUpdateTimestamp\", type: \"uint40\" }\n            ],\n            stateMutability: \"view\",\n            type: \"function\"\n        }\n    ];\n\n    const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n    try {\n        const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n        const liquidityRate = reserveData[3];       // ray\n        const variableBorrowRate = reserveData[4];  // ray\n        const stableBorrowRate = reserveData[5];    // ray\n\n        const RAY = 1e27;\n        const SECONDS_PER_YEAR = 31536000;\n\n        function toAPY(rate) {\n            const apr = Number(rate) / RAY;\n            return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n        }\n\n        return {\n            apy: toAPY(liquidityRate).toFixed(2),\n            borrowApy: toAPY(variableBorrowRate).toFixed(2),\n            rewardApy: toAPY(stableBorrowRate).toFixed(2),\n        };\n\n    } catch (err) {\n        console.error('Aave Error fetching Aave APY:', err);\n        return err.message || 'Internal error';\n    }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0xf251030DAeA3F09ed7D118F57F4b91F281250527\";\n    const marketAddress = \"0xA950974f64aA33f27F6C5e017eEE93BF7588ED07\"\n\n    const radiantWithdrawABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"lendingPool\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            name: \"withdrawETH\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: radiantWithdrawABI,\n            functionName: \"withdrawETH\",\n            args: [marketAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0xf251030DAeA3F09ed7D118F57F4b91F281250527\";\n    const marketAddress = \"0xA950974f64aA33f27F6C5e017eEE93BF7588ED07\"\n\n    const radiantDepositABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"lendingPool\", \"type\": \"address\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"depositETH\",\n            stateMutability: \"payable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: radiantDepositABI,\n            functionName: \"depositETH\",\n            args: [marketAddress, address, 0],\n            value: amountInWei,\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "",
  "yieldBearingToken": "0xd10c315293872851184F484E9431dAf4dE6AA992",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6cf8a30d28f1784f33356"
  },
  "asset": {
    "$oid": "68b14b6bf55db3d0dfa7df5e"
  },
  "protocol": {
    "$oid": "68b00cf8c849df1b70af1903"
  },
  "apy": "(async function (ethers) {\n    const tokenAddress = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\";\n    const rpcUrl = \"https://eth.rpc.blxrbdn.com\";\n    const provider = new ethers.JsonRpcProvider(rpcUrl);\n    const marketAddress = \"0xA950974f64aA33f27F6C5e017eEE93BF7588ED07\";\n\n    const aaveABI = [\n        {\n            inputs: [{ name: \"asset\", type: \"address\" }],\n            name: \"getReserveData\",\n            outputs: [\n                { name: \"availableLiquidity\", type: \"uint256\" },\n                { name: \"totalStableDebt\", type: \"uint256\" },\n                { name: \"totalVariableDebt\", type: \"uint256\" },\n                { name: \"liquidityRate\", type: \"uint256\" },\n                { name: \"variableBorrowRate\", type: \"uint256\" },\n                { name: \"stableBorrowRate\", type: \"uint256\" },\n                { name: \"averageStableBorrowRate\", type: \"uint256\" },\n                { name: \"liquidityIndex\", type: \"uint256\" },\n                { name: \"variableBorrowIndex\", type: \"uint256\" },\n                { name: \"lastUpdateTimestamp\", type: \"uint40\" }\n            ],\n            stateMutability: \"view\",\n            type: \"function\"\n        }\n    ];\n\n    const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n    try {\n        const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n        const liquidityRate = reserveData[3];       // ray\n        const variableBorrowRate = reserveData[4];  // ray\n        const stableBorrowRate = reserveData[5];    // ray\n\n        const RAY = 1e27;\n        const SECONDS_PER_YEAR = 31536000;\n\n        function toAPY(rate) {\n            const apr = Number(rate) / RAY;\n            return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n        }\n\n        return {\n            apy: toAPY(liquidityRate).toFixed(2),\n            borrowApy: toAPY(variableBorrowRate).toFixed(2),\n            rewardApy: toAPY(stableBorrowRate).toFixed(2),\n        };\n\n    } catch (err) {\n        console.error('Aave Error fetching Aave APY:', err);\n        return err.message || 'Internal error';\n    }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\"\n    const marketAddress = \"0xA950974f64aA33f27F6C5e017eEE93BF7588ED07\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\"\n    const rpcUrl = \"https://eth.rpc.blxrbdn.com\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0xA950974f64aA33f27F6C5e017eEE93BF7588ED07\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  "yieldBearingToken": "0x9E85DF2B42b2aE5e666D7263ED81a744a534BF1f",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6cfaf30d28f1784f33357"
  },
  "asset": {
    "$oid": "68b14b85f55db3d0dfa7df62"
  },
  "protocol": {
    "$oid": "68b00cf8c849df1b70af1903"
  },
  "apy": "(async function (ethers) {\n    const tokenAddress = \"0xdac17f958d2ee523a2206206994597c13d831ec7\";\n    const rpcUrl = \"https://eth.rpc.blxrbdn.com\";\n    const provider = new ethers.JsonRpcProvider(rpcUrl);\n    const marketAddress = \"0xA950974f64aA33f27F6C5e017eEE93BF7588ED07\";\n\n    const aaveABI = [\n        {\n            inputs: [{ name: \"asset\", type: \"address\" }],\n            name: \"getReserveData\",\n            outputs: [\n                { name: \"availableLiquidity\", type: \"uint256\" },\n                { name: \"totalStableDebt\", type: \"uint256\" },\n                { name: \"totalVariableDebt\", type: \"uint256\" },\n                { name: \"liquidityRate\", type: \"uint256\" },\n                { name: \"variableBorrowRate\", type: \"uint256\" },\n                { name: \"stableBorrowRate\", type: \"uint256\" },\n                { name: \"averageStableBorrowRate\", type: \"uint256\" },\n                { name: \"liquidityIndex\", type: \"uint256\" },\n                { name: \"variableBorrowIndex\", type: \"uint256\" },\n                { name: \"lastUpdateTimestamp\", type: \"uint40\" }\n            ],\n            stateMutability: \"view\",\n            type: \"function\"\n        }\n    ];\n\n    const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n    try {\n        const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n        const liquidityRate = reserveData[3];       // ray\n        const variableBorrowRate = reserveData[4];  // ray\n        const stableBorrowRate = reserveData[5];    // ray\n\n        const RAY = 1e27;\n        const SECONDS_PER_YEAR = 31536000;\n\n        function toAPY(rate) {\n            const apr = Number(rate) / RAY;\n            return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n        }\n\n        return {\n            apy: toAPY(liquidityRate).toFixed(2),\n            borrowApy: toAPY(variableBorrowRate).toFixed(2),\n            rewardApy: toAPY(stableBorrowRate).toFixed(2),\n        };\n\n    } catch (err) {\n        console.error('Aave Error fetching Aave APY:', err);\n        return err.message || 'Internal error';\n    }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xdac17f958d2ee523a2206206994597c13d831ec7\"\n    const marketAddress = \"0xA950974f64aA33f27F6C5e017eEE93BF7588ED07\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xdac17f958d2ee523a2206206994597c13d831ec7\"\n    const rpcUrl = \"https://eth.rpc.blxrbdn.com\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0xA950974f64aA33f27F6C5e017eEE93BF7588ED07\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0xdac17f958d2ee523a2206206994597c13d831ec7",
  "yieldBearingToken": "0x3c19d9F2Df0E25C077A637692DA2337D51daf8B7",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6d26830d28f1784f33358"
  },
  "asset": {
    "$oid": "68b0218cc849df1b70af195c"
  },
  "protocol": {
    "$oid": "68b00cf8c849df1b70af1903"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\";\n  const rpcUrl = \"https://bsc.drpc.org\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0xccf31d54c3a94f67b8ceff8dd771de5846da032c\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[3];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0xD0FC69Dc0e720d5be669E53b7B5015F6FC258Ac9\";\n    const marketAddress = \"0xccf31d54c3a94f67b8ceff8dd771de5846da032c\"\n\n    const radiantWithdrawABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"lendingPool\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            name: \"withdrawETH\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: radiantWithdrawABI,\n            functionName: \"withdrawETH\",\n            args: [marketAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0xD0FC69Dc0e720d5be669E53b7B5015F6FC258Ac9\";\n    const marketAddress = \"0xccf31d54c3a94f67b8ceff8dd771de5846da032c\"\n\n    const radiantDepositABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"lendingPool\", \"type\": \"address\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"depositETH\",\n            stateMutability: \"payable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: radiantDepositABI,\n            functionName: \"depositETH\",\n            args: [marketAddress, address, 0],\n            value: amountInWei,\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "",
  "yieldBearingToken": "0x40351090037b9c4f6555071e9B24A82B068F2c05",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6d29730d28f1784f33359"
  },
  "asset": {
    "$oid": "68af071df48122df91aa93b1"
  },
  "protocol": {
    "$oid": "68b00cf8c849df1b70af1903"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d\";\n  const rpcUrl = \"https://bsc.drpc.org\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0xccf31d54c3a94f67b8ceff8dd771de5846da032c\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[3];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d\"\n    const marketAddress = \"0xccf31d54c3a94f67b8ceff8dd771de5846da032c\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d\"\n    const rpcUrl = \"https://bsc.drpc.org\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0xccf31d54c3a94f67b8ceff8dd771de5846da032c\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
  "yieldBearingToken": "0x15cc621cfD1D0527CE6894fc07D97B2C06520D57",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6d2b130d28f1784f3335a"
  },
  "asset": {
    "$oid": "68b14ac3f55db3d0dfa7df53"
  },
  "protocol": {
    "$oid": "68b00cf8c849df1b70af1903"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0x55d398326f99059ff775485246999027b3197955\";\n  const rpcUrl = \"https://bsc.drpc.org\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0xccf31d54c3a94f67b8ceff8dd771de5846da032c\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[3];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0x55d398326f99059ff775485246999027b3197955\"\n    const marketAddress = \"0xccf31d54c3a94f67b8ceff8dd771de5846da032c\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0x55d398326f99059ff775485246999027b3197955\"\n    const rpcUrl = \"https://bsc.drpc.org\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0xccf31d54c3a94f67b8ceff8dd771de5846da032c\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0x55d398326f99059ff775485246999027b3197955",
  "yieldBearingToken": "0x9915A7389f8FB33f9b77d84119c06e8BFfB12BE4",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6d32230d28f1784f3335b"
  },
  "asset": {
    "$oid": "68b14caff55db3d0dfa7df74"
  },
  "protocol": {
    "$oid": "68b00cf8c849df1b70af1903"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0x82af49447d8a07e3bd95bd0d56f35241523fbab1\";\n  const rpcUrl = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0xE23B4AE3624fB6f7cDEF29bC8EAD912f1Ede6886\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[3];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0x8a8f65CABb82A857fA22289Ad0a5785a5E7dBD22\";\n    const marketAddress = \"0xE23B4AE3624fB6f7cDEF29bC8EAD912f1Ede6886\"\n\n    const radiantWithdrawABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"lendingPool\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            name: \"withdrawETH\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: radiantWithdrawABI,\n            functionName: \"withdrawETH\",\n            args: [marketAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0x8a8f65CABb82A857fA22289Ad0a5785a5E7dBD22\";\n    const marketAddress = \"0xE23B4AE3624fB6f7cDEF29bC8EAD912f1Ede6886\"\n\n    const radiantDepositABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"lendingPool\", \"type\": \"address\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"depositETH\",\n            stateMutability: \"payable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: radiantDepositABI,\n            functionName: \"depositETH\",\n            args: [marketAddress, address, 0],\n            value: amountInWei,\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "",
  "yieldBearingToken": "0xfB6f79Db694Ab6B7bf9Eb71b3e2702191A91dF56",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6d34330d28f1784f3335c"
  },
  "asset": {
    "$oid": "68b14cd8f55db3d0dfa7df75"
  },
  "protocol": {
    "$oid": "68b00cf8c849df1b70af1903"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0xaf88d065e77c8cc2239327c5edb3a432268e5831\";\n  const rpcUrl = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0xE23B4AE3624fB6f7cDEF29bC8EAD912f1Ede6886\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[3];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xaf88d065e77c8cc2239327c5edb3a432268e5831\"\n    const marketAddress = \"0xE23B4AE3624fB6f7cDEF29bC8EAD912f1Ede6886\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xaf88d065e77c8cc2239327c5edb3a432268e5831\"\n    const rpcUrl = \"https://arb1.arbitrum.io/rpc\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0xE23B4AE3624fB6f7cDEF29bC8EAD912f1Ede6886\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0xaf88d065e77c8cc2239327c5edb3a432268e5831",
  "yieldBearingToken": "0xb1D71c15D7c00A1b38C7ad182FA49889A70DB4be",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6d36130d28f1784f3335d"
  },
  "asset": {
    "$oid": "68b14ce5f55db3d0dfa7df79"
  },
  "protocol": {
    "$oid": "68b00cf8c849df1b70af1903"
  },
  "apy": "(async function (ethers) {\n  const tokenAddress = \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\";\n  const rpcUrl = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0xE23B4AE3624fB6f7cDEF29bC8EAD912f1Ede6886\";\n\n  const aaveABI = [\n    {\n      inputs: [{ name: 'asset', type: 'address' }],\n      name: 'getReserveData',\n      outputs: [\n        { name: 'availableLiquidity', type: 'uint256' },\n        { name: 'totalStableDebt', type: 'uint256' },\n        { name: 'totalVariableDebt', type: 'uint256' },\n        { name: 'liquidityRate', type: 'uint256' },\n        { name: 'variableBorrowRate', type: 'uint256' },\n        { name: 'stableBorrowRate', type: 'uint256' },\n        { name: 'averageStableBorrowRate', type: 'uint256' },\n        { name: 'liquidityIndex', type: 'uint256' },\n        { name: 'variableBorrowIndex', type: 'uint256' },\n        { name: 'lastUpdateTimestamp', type: 'uint40' }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const dataProvider = new ethers.Contract(marketAddress, aaveABI, provider);\n\n  try {\n    const reserveData = await dataProvider.getReserveData(tokenAddress);\n\n    const liquidityRate = reserveData[3];       // ray\n    const variableBorrowRate = reserveData[4];  // ray\n    const stableBorrowRate = reserveData[5];    // ray\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rate) {\n      const apr = Number(rate) / RAY;\n      return (Math.pow(1 + apr / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100;\n    }\n\n    return {\n      apy: toAPY(liquidityRate).toFixed(2),\n      borrowApy: toAPY(variableBorrowRate).toFixed(2),\n      rewardApy: toAPY(stableBorrowRate).toFixed(2),\n    };\n\n  } catch (err) {\n    console.error('Aave Error fetching Aave APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\"\n    const marketAddress = \"0xE23B4AE3624fB6f7cDEF29bC8EAD912f1Ede6886\"\n\n    const aaveV3WithdrawABI = [\n        {\n            \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }],\n            \"name\": \"withdraw\",\n            \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n            \"stateMutability\": \"nonpayable\", \"type\": \"function\"\n        }];\n    \n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3WithdrawABI,\n            functionName: \"withdraw\",\n            args: [tokenAddress, amountInWei, address],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const tokenAddress = \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\"\n    const rpcUrl = \"https://arb1.arbitrum.io/rpc\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n    const marketAddress = \"0xE23B4AE3624fB6f7cDEF29bC8EAD912f1Ede6886\"\n\n    const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const aaveV3SupplyABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }, { \"internalType\": \"address\", \"name\": \"onBehalfOf\", \"type\": \"address\" }, { \"internalType\": \"uint16\", \"name\": \"referralCode\", \"type\": \"uint16\" }],\n            name: \"supply\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, marketAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: tokenAddress,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [marketAddress, amountInWei],\n                chainId\n            });\n        }\n\n        success = true; // Already approved\n        txHash = await writeContractAsync({\n            address: marketAddress,\n            abi: aaveV3SupplyABI,\n            functionName: \"supply\",\n            args: [tokenAddress, amountInWei, address, 0],\n            chainId\n        });\n        return txHash;\n\n    } catch (err) {\n        return err;\n    }\n}",
  "underlyingAsset": "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
  "yieldBearingToken": "0x62f9F05F3af1A934f0e02EAd202E3de36a6501E6",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6dcc0a7c8236c6e7fa4e5"
  },
  "asset": {
    "$oid": "68b14b46f55db3d0dfa7df5d"
  },
  "protocol": {
    "$oid": "68b00cf1c849df1b70af1902"
  },
  "apy": "(async function (ethers) {\n  const rpcUrl = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0xA17581A9E3356d9A858b789D68B4d866e593aE94\";\n\n  const compoundV3ABI = [\n    {\n      inputs: [],\n      name: 'getUtilization',\n      outputs: [{ name: '', type: 'uint256' }],\n      stateMutability: 'view',\n      type: 'function'\n    },\n    {\n      inputs: [{ name: 'utilization', type: 'uint256' }],\n      name: 'getSupplyRate',\n      outputs: [{ name: '', type: 'uint64' }],\n      stateMutability: 'view',\n      type: 'function'\n    },\n    {\n      inputs: [{ name: 'utilization', type: 'uint256' }],\n      name: 'getBorrowRate',\n      outputs: [{ name: '', type: 'uint64' }],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const contract = new ethers.Contract(marketAddress, compoundV3ABI, provider);\n\n  try {\n    const utilization = await contract.getUtilization();\n    const supplyRate = await contract.getSupplyRate(utilization);\n    const borrowRate = await contract.getBorrowRate(utilization);\n\n    const rateDecimal = Number(ethers.formatUnits(supplyRate, 18));\n    const borrowRateDecimal = Number(ethers.formatUnits(borrowRate, 18));\n\n    const SECONDS_PER_YEAR = 31536000;\n\n    const toApy = (rate) => {\n      if (rate < 0.000001) return rate * SECONDS_PER_YEAR * 100;\n      try {\n        const apy = (Math.pow(1 + rate, SECONDS_PER_YEAR) - 1) * 100;\n        return !isFinite(apy) || apy > 1000 ? rate * SECONDS_PER_YEAR * 100 : apy;\n      } catch {\n        return rate * SECONDS_PER_YEAR * 100;\n      }\n    };\n\n    const supplyApy = toApy(rateDecimal);\n    const borrowApy = toApy(borrowRateDecimal);\n\n    return {\n      apy: supplyApy.toFixed(2),   // supply APY only\n      borrowApy: borrowApy.toFixed(2),\n      rewardApy: \"0.00\"            // reward excluded\n    };\n\n  } catch (err) {\n    console.error('Compound Error fetching Compound APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const abiCoder = ethers.AbiCoder.defaultAbiCoder();\n    const action = \"ACTION_WITHDRAW_NATIVE_TOKEN\";\n    const callingAddress = \"0xa397a8C2086C554B531c02E29f3291c9704B00c7\";\n    const marketAddress = \"0xA17581A9E3356d9A858b789D68B4d866e593aE94\"\n\n    const compoundDepositABI = [\n        {\n            inputs: [{ \"internalType\": \"bytes32[]\", \"name\": \"actions\", \"type\": \"bytes32[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"data\", \"type\": \"bytes[]\" }],\n            name: \"invoke\",\n            stateMutability: \"payable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        const actions = ethers.encodeBytes32String(action);\n        const data = abiCoder.encode(\n            [\"address\", \"address\", \"uint256\"],\n            [marketAddress, address, amountInWei]\n        );\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: compoundDepositABI,\n            functionName: \"invoke\",\n            args: [actions, data],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err.message || 'Internal error';\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const abiCoder = ethers.AbiCoder.defaultAbiCoder();\n    const action = \"ACTION_SUPPLY_NATIVE_TOKEN\";\n    const callingAddress = \"0xa397a8C2086C554B531c02E29f3291c9704B00c7\";\n    const marketAddress = \"0xA17581A9E3356d9A858b789D68B4d866e593aE94\"\n\n    const compoundDepositABI = [\n        {\n            inputs: [{ \"internalType\": \"bytes32[]\", \"name\": \"actions\", \"type\": \"bytes32[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"data\", \"type\": \"bytes[]\" }],\n            name: \"invoke\",\n            stateMutability: \"payable\",\n            type: \"function\"\n        }\n    ];\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        const actions = ethers.encodeBytes32String(action);\n        const data = abiCoder.encode(\n            [\"address\", \"address\", \"uint256\"],\n            [marketAddress, address, amountInWei]\n        );\n\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: compoundDepositABI,\n            functionName: \"invoke\",\n            args: [actions, data],\n            value: amountInWei,\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err.message || 'Internal error';\n    }\n}",
  "underlyingAsset": "",
  "yieldBearingToken": "0xA17581A9E3356d9A858b789D68B4d866e593aE94",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6e06ac06415c865d69d7b"
  },
  "asset": {
    "$oid": "68b14b6bf55db3d0dfa7df5e"
  },
  "protocol": {
    "$oid": "68b00cf1c849df1b70af1902"
  },
  "apy": "(async function (ethers) {\n  const rpcUrl = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0xc3d688B66703497DAA19211EEdff47f25384cdc3\";\n\n  const compoundV3ABI = [\n    {\n      inputs: [],\n      name: 'getUtilization',\n      outputs: [{ name: '', type: 'uint256' }],\n      stateMutability: 'view',\n      type: 'function'\n    },\n    {\n      inputs: [{ name: 'utilization', type: 'uint256' }],\n      name: 'getSupplyRate',\n      outputs: [{ name: '', type: 'uint64' }],\n      stateMutability: 'view',\n      type: 'function'\n    },\n    {\n      inputs: [{ name: 'utilization', type: 'uint256' }],\n      name: 'getBorrowRate',\n      outputs: [{ name: '', type: 'uint64' }],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const contract = new ethers.Contract(marketAddress, compoundV3ABI, provider);\n\n  try {\n    const utilization = await contract.getUtilization();\n    const supplyRate = await contract.getSupplyRate(utilization);\n    const borrowRate = await contract.getBorrowRate(utilization);\n\n    const rateDecimal = Number(ethers.formatUnits(supplyRate, 18));\n    const borrowRateDecimal = Number(ethers.formatUnits(borrowRate, 18));\n\n    const SECONDS_PER_YEAR = 31536000;\n\n    const toApy = (rate) => {\n      if (rate < 0.000001) return rate * SECONDS_PER_YEAR * 100;\n      try {\n        const apy = (Math.pow(1 + rate, SECONDS_PER_YEAR) - 1) * 100;\n        return !isFinite(apy) || apy > 1000 ? rate * SECONDS_PER_YEAR * 100 : apy;\n      } catch {\n        return rate * SECONDS_PER_YEAR * 100;\n      }\n    };\n\n    const supplyApy = toApy(rateDecimal);\n    const borrowApy = toApy(borrowRateDecimal);\n\n    return {\n      apy: supplyApy.toFixed(2),   // supply APY only\n      borrowApy: borrowApy.toFixed(2),\n      rewardApy: \"0.00\"            // reward excluded\n    };\n\n  } catch (err) {\n    console.error('Compound Error fetching Compound APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0xc3d688B66703497DAA19211EEdff47f25384cdc3\";\n    const asset = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"; // USDC\n\n    const compoundWithdrawABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }],\n            name: \"withdraw\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: compoundWithdrawABI,\n            functionName: \"withdraw\",\n            args: [asset, amountInWei],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err.message || 'Internal error';\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0xc3d688B66703497DAA19211EEdff47f25384cdc3\";\n    const asset = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"; // USDC\n    const rpcUrl = \"https://eth.rpc.blxrbdn.com\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n\n     const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const compoundDepositABI = [{\n        inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }],\n        name: \"supply\",\n        stateMutability: \"nonpayable\",\n        type: \"function\"\n    }];\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n         // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            asset,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, callingAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: asset,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [callingAddress, amountInWei],\n                chainId\n            });\n        }\n\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: compoundDepositABI,\n            functionName: \"supply\",\n            args: [asset, amountInWei],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err.message || 'Internal error';\n    }\n}",
  "underlyingAsset": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  "yieldBearingToken": "0xc3d688B66703497DAA19211EEdff47f25384cdc3",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6e08fc06415c865d69d7d"
  },
  "asset": {
    "$oid": "68b14b85f55db3d0dfa7df62"
  },
  "protocol": {
    "$oid": "68b00cf1c849df1b70af1902"
  },
  "apy": "(async function (ethers) {\n  const rpcUrl = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x3Afdc9BCA9213A35503b077a6072F3D0d5AB0840\";\n\n  const compoundV3ABI = [\n    {\n      inputs: [],\n      name: 'getUtilization',\n      outputs: [{ name: '', type: 'uint256' }],\n      stateMutability: 'view',\n      type: 'function'\n    },\n    {\n      inputs: [{ name: 'utilization', type: 'uint256' }],\n      name: 'getSupplyRate',\n      outputs: [{ name: '', type: 'uint64' }],\n      stateMutability: 'view',\n      type: 'function'\n    },\n    {\n      inputs: [{ name: 'utilization', type: 'uint256' }],\n      name: 'getBorrowRate',\n      outputs: [{ name: '', type: 'uint64' }],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const contract = new ethers.Contract(marketAddress, compoundV3ABI, provider);\n\n  try {\n    const utilization = await contract.getUtilization();\n    const supplyRate = await contract.getSupplyRate(utilization);\n    const borrowRate = await contract.getBorrowRate(utilization);\n\n    const rateDecimal = Number(ethers.formatUnits(supplyRate, 18));\n    const borrowRateDecimal = Number(ethers.formatUnits(borrowRate, 18));\n\n    const SECONDS_PER_YEAR = 31536000;\n\n    const toApy = (rate) => {\n      if (rate < 0.000001) return rate * SECONDS_PER_YEAR * 100;\n      try {\n        const apy = (Math.pow(1 + rate, SECONDS_PER_YEAR) - 1) * 100;\n        return !isFinite(apy) || apy > 1000 ? rate * SECONDS_PER_YEAR * 100 : apy;\n      } catch {\n        return rate * SECONDS_PER_YEAR * 100;\n      }\n    };\n\n    const supplyApy = toApy(rateDecimal);\n    const borrowApy = toApy(borrowRateDecimal);\n\n    return {\n      apy: supplyApy.toFixed(2),   // supply APY only\n      borrowApy: borrowApy.toFixed(2),\n      rewardApy: \"0.00\"            // reward excluded\n    };\n\n  } catch (err) {\n    console.error('Compound Error fetching Compound APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0x3Afdc9BCA9213A35503b077a6072F3D0d5AB0840\";\n    const asset = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\"; // USDT\n\n    const compoundWithdrawABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }],\n            name: \"withdraw\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: compoundWithdrawABI,\n            functionName: \"withdraw\",\n            args: [asset, amountInWei],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err.message || 'Internal error';\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0x3Afdc9BCA9213A35503b077a6072F3D0d5AB0840\";\n    const asset = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\"; // USDT\n    const rpcUrl = \"https://eth.rpc.blxrbdn.com\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n\n     const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const compoundDepositABI = [{\n        inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }],\n        name: \"supply\",\n        stateMutability: \"nonpayable\",\n        type: \"function\"\n    }];\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n         // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            asset,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, callingAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: asset,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [callingAddress, amountInWei],\n                chainId\n            });\n        }\n\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: compoundDepositABI,\n            functionName: \"supply\",\n            args: [asset, amountInWei],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err.message || 'Internal error';\n    }\n}",
  "underlyingAsset": "0xdac17f958d2ee523a2206206994597c13d831ec7",
  "yieldBearingToken": "0x3Afdc9BCA9213A35503b077a6072F3D0d5AB0840",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6e138c06415c865d69d7e"
  },
  "asset": {
    "$oid": "68b14caff55db3d0dfa7df74"
  },
  "protocol": {
    "$oid": "68b00cf1c849df1b70af1902"
  },
  "apy": "(async function (ethers) {\n  const rpcUrl = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x6f7D514bbD4aFf3BcD1140B7344b32f063dEe486\";\n\n  const compoundV3ABI = [\n    {\n      inputs: [],\n      name: 'getUtilization',\n      outputs: [{ name: '', type: 'uint256' }],\n      stateMutability: 'view',\n      type: 'function'\n    },\n    {\n      inputs: [{ name: 'utilization', type: 'uint256' }],\n      name: 'getSupplyRate',\n      outputs: [{ name: '', type: 'uint64' }],\n      stateMutability: 'view',\n      type: 'function'\n    },\n    {\n      inputs: [{ name: 'utilization', type: 'uint256' }],\n      name: 'getBorrowRate',\n      outputs: [{ name: '', type: 'uint64' }],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const contract = new ethers.Contract(marketAddress, compoundV3ABI, provider);\n\n  try {\n    const utilization = await contract.getUtilization();\n    const supplyRate = await contract.getSupplyRate(utilization);\n    const borrowRate = await contract.getBorrowRate(utilization);\n\n    const rateDecimal = Number(ethers.formatUnits(supplyRate, 18));\n    const borrowRateDecimal = Number(ethers.formatUnits(borrowRate, 18));\n\n    const SECONDS_PER_YEAR = 31536000;\n\n    const toApy = (rate) => {\n      if (rate < 0.000001) return rate * SECONDS_PER_YEAR * 100;\n      try {\n        const apy = (Math.pow(1 + rate, SECONDS_PER_YEAR) - 1) * 100;\n        return !isFinite(apy) || apy > 1000 ? rate * SECONDS_PER_YEAR * 100 : apy;\n      } catch {\n        return rate * SECONDS_PER_YEAR * 100;\n      }\n    };\n\n    const supplyApy = toApy(rateDecimal);\n    const borrowApy = toApy(borrowRateDecimal);\n\n    return {\n      apy: supplyApy.toFixed(2),   // supply APY only\n      borrowApy: borrowApy.toFixed(2),\n      rewardApy: \"0.00\"            // reward excluded\n    };\n\n  } catch (err) {\n    console.error('Compound Error fetching Compound APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const abiCoder = ethers.AbiCoder.defaultAbiCoder();\n    const action = \"ACTION_WITHDRAW_NATIVE_TOKEN\";\n    const callingAddress = \"0xbdE8F31D2DdDA895264e27DD990faB3DC87b372d\";\n    const marketAddress = \"0x6f7D514bbD4aFf3BcD1140B7344b32f063dEe486\"\n\n    const compoundDepositABI = [\n        {\n            inputs: [{ \"internalType\": \"bytes32[]\", \"name\": \"actions\", \"type\": \"bytes32[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"data\", \"type\": \"bytes[]\" }],\n            name: \"invoke\",\n            stateMutability: \"payable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        const actions = ethers.encodeBytes32String(action);\n        const data = abiCoder.encode(\n            [\"address\", \"address\", \"uint256\"],\n            [marketAddress, address, amountInWei]\n        );\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: compoundDepositABI,\n            functionName: \"invoke\",\n            args: [actions, data],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err.message || 'Internal error';\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const abiCoder = ethers.AbiCoder.defaultAbiCoder();\n    const action = \"ACTION_SUPPLY_NATIVE_TOKEN\";\n    const callingAddress = \"0xbdE8F31D2DdDA895264e27DD990faB3DC87b372d\";\n    const marketAddress = \"0x6f7D514bbD4aFf3BcD1140B7344b32f063dEe486\"\n\n    const compoundDepositABI = [\n        {\n            inputs: [{ \"internalType\": \"bytes32[]\", \"name\": \"actions\", \"type\": \"bytes32[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"data\", \"type\": \"bytes[]\" }],\n            name: \"invoke\",\n            stateMutability: \"payable\",\n            type: \"function\"\n        }\n    ];\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n        const actions = ethers.encodeBytes32String(action);\n        const data = abiCoder.encode(\n            [\"address\", \"address\", \"uint256\"],\n            [marketAddress, address, amountInWei]\n        );\n\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: compoundDepositABI,\n            functionName: \"invoke\",\n            args: [actions, data],\n            value: amountInWei,\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err.message || 'Internal error';\n    }\n}",
  "underlyingAsset": "",
  "yieldBearingToken": "0x6f7D514bbD4aFf3BcD1140B7344b32f063dEe486",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6e162c06415c865d69d7f"
  },
  "asset": {
    "$oid": "68b14cd8f55db3d0dfa7df75"
  },
  "protocol": {
    "$oid": "68b00cf1c849df1b70af1902"
  },
  "apy": "(async function (ethers) {\n  const rpcUrl = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0x9c4ec768c28520B50860ea7a15bd7213a9fF58bf\";\n\n  const compoundV3ABI = [\n    {\n      inputs: [],\n      name: 'getUtilization',\n      outputs: [{ name: '', type: 'uint256' }],\n      stateMutability: 'view',\n      type: 'function'\n    },\n    {\n      inputs: [{ name: 'utilization', type: 'uint256' }],\n      name: 'getSupplyRate',\n      outputs: [{ name: '', type: 'uint64' }],\n      stateMutability: 'view',\n      type: 'function'\n    },\n    {\n      inputs: [{ name: 'utilization', type: 'uint256' }],\n      name: 'getBorrowRate',\n      outputs: [{ name: '', type: 'uint64' }],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const contract = new ethers.Contract(marketAddress, compoundV3ABI, provider);\n\n  try {\n    const utilization = await contract.getUtilization();\n    const supplyRate = await contract.getSupplyRate(utilization);\n    const borrowRate = await contract.getBorrowRate(utilization);\n\n    const rateDecimal = Number(ethers.formatUnits(supplyRate, 18));\n    const borrowRateDecimal = Number(ethers.formatUnits(borrowRate, 18));\n\n    const SECONDS_PER_YEAR = 31536000;\n\n    const toApy = (rate) => {\n      if (rate < 0.000001) return rate * SECONDS_PER_YEAR * 100;\n      try {\n        const apy = (Math.pow(1 + rate, SECONDS_PER_YEAR) - 1) * 100;\n        return !isFinite(apy) || apy > 1000 ? rate * SECONDS_PER_YEAR * 100 : apy;\n      } catch {\n        return rate * SECONDS_PER_YEAR * 100;\n      }\n    };\n\n    const supplyApy = toApy(rateDecimal);\n    const borrowApy = toApy(borrowRateDecimal);\n\n    return {\n      apy: supplyApy.toFixed(2),   // supply APY only\n      borrowApy: borrowApy.toFixed(2),\n      rewardApy: \"0.00\"            // reward excluded\n    };\n\n  } catch (err) {\n    console.error('Compound Error fetching Compound APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0x9c4ec768c28520B50860ea7a15bd7213a9fF58bf\";\n    const asset = \"0xaf88d065e77c8cC2239327C5EDb3A432268e5831\"; // USDC\n\n    const compoundWithdrawABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }],\n            name: \"withdraw\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: compoundWithdrawABI,\n            functionName: \"withdraw\",\n            args: [asset, amountInWei],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err.message || 'Internal error';\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0x9c4ec768c28520B50860ea7a15bd7213a9fF58bf\";\n    const asset = \"0xaf88d065e77c8cC2239327C5EDb3A432268e5831\"; // USDC\n    const rpcUrl = \"https://arb1.arbitrum.io/rpc\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n\n     const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const compoundDepositABI = [{\n        inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }],\n        name: \"supply\",\n        stateMutability: \"nonpayable\",\n        type: \"function\"\n    }];\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n         // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            asset,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, callingAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: asset,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [callingAddress, amountInWei],\n                chainId\n            });\n        }\n\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: compoundDepositABI,\n            functionName: \"supply\",\n            args: [asset, amountInWei],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err.message || 'Internal error';\n    }\n}",
  "underlyingAsset": "0xaf88d065e77c8cc2239327c5edb3a432268e5831",
  "yieldBearingToken": "0x9c4ec768c28520B50860ea7a15bd7213a9fF58bf",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68b6e181c06415c865d69d81"
  },
  "asset": {
    "$oid": "68b14ce5f55db3d0dfa7df79"
  },
  "protocol": {
    "$oid": "68b00cf1c849df1b70af1902"
  },
  "apy": "(async function (ethers) {\n  const rpcUrl = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n  const marketAddress = \"0xd98Be00b5D27fc98112BdE293e487f8D4cA57d07\";\n\n  const compoundV3ABI = [\n    {\n      inputs: [],\n      name: 'getUtilization',\n      outputs: [{ name: '', type: 'uint256' }],\n      stateMutability: 'view',\n      type: 'function'\n    },\n    {\n      inputs: [{ name: 'utilization', type: 'uint256' }],\n      name: 'getSupplyRate',\n      outputs: [{ name: '', type: 'uint64' }],\n      stateMutability: 'view',\n      type: 'function'\n    },\n    {\n      inputs: [{ name: 'utilization', type: 'uint256' }],\n      name: 'getBorrowRate',\n      outputs: [{ name: '', type: 'uint64' }],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ];\n\n  const contract = new ethers.Contract(marketAddress, compoundV3ABI, provider);\n\n  try {\n    const utilization = await contract.getUtilization();\n    const supplyRate = await contract.getSupplyRate(utilization);\n    const borrowRate = await contract.getBorrowRate(utilization);\n\n    const rateDecimal = Number(ethers.formatUnits(supplyRate, 18));\n    const borrowRateDecimal = Number(ethers.formatUnits(borrowRate, 18));\n\n    const SECONDS_PER_YEAR = 31536000;\n\n    const toApy = (rate) => {\n      if (rate < 0.000001) return rate * SECONDS_PER_YEAR * 100;\n      try {\n        const apy = (Math.pow(1 + rate, SECONDS_PER_YEAR) - 1) * 100;\n        return !isFinite(apy) || apy > 1000 ? rate * SECONDS_PER_YEAR * 100 : apy;\n      } catch {\n        return rate * SECONDS_PER_YEAR * 100;\n      }\n    };\n\n    const supplyApy = toApy(rateDecimal);\n    const borrowApy = toApy(borrowRateDecimal);\n\n    return {\n      apy: supplyApy.toFixed(2),   // supply APY only\n      borrowApy: borrowApy.toFixed(2),\n      rewardApy: \"0.00\"            // reward excluded\n    };\n\n  } catch (err) {\n    console.error('Compound Error fetching Compound APY:', err);\n    return err.message || 'Internal error';\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0xd98Be00b5D27fc98112BdE293e487f8D4cA57d07\";\n    const asset = \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\"; // USDT\n\n    const compoundWithdrawABI = [\n        {\n            inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }],\n            name: \"withdraw\",\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: compoundWithdrawABI,\n            functionName: \"withdraw\",\n            args: [asset, amountInWei],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err.message || 'Internal error';\n    }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n    const callingAddress = \"0xd98Be00b5D27fc98112BdE293e487f8D4cA57d07\";\n    const asset = \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\"; // USDT\n    const rpcUrl = \"https://arb1.arbitrum.io/rpc\"\n    const provider = new ethers.JsonRpcProvider(rpcUrl)\n\n     const erc20Abi = [\n        {\n            inputs: [\n                { name: \"owner\", type: \"address\" },\n                { name: \"spender\", type: \"address\" }\n            ],\n            name: \"allowance\",\n            outputs: [{ name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n        },\n        {\n            inputs: [\n                { name: \"spender\", type: \"address\" },\n                { name: \"amount\", type: \"uint256\" }\n            ],\n            name: \"approve\",\n            outputs: [{ name: \"\", type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n            type: \"function\"\n        }\n    ];\n\n    const compoundDepositABI = [{\n        inputs: [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }],\n        name: \"supply\",\n        stateMutability: \"nonpayable\",\n        type: \"function\"\n    }];\n    try {\n        let success = false;\n        let txHash = \"\";\n        const amountInWei = parseUnits(amount, tokenDecimals);\n\n         // 1. Check allowance\n        const erc20Contract = new ethers.Contract(\n            asset,\n            erc20Abi,\n            provider\n        );\n\n        const allowance = await erc20Contract.allowance(address, callingAddress)\n\n        // 2. Approve if needed\n        if (BigInt(allowance) < amountInWei) {\n            await writeContractAsync({\n                address: asset,\n                abi: erc20Abi,\n                functionName: \"approve\",\n                args: [callingAddress, amountInWei],\n                chainId\n            });\n        }\n\n        txHash = await writeContractAsync({\n            address: callingAddress,\n            abi: compoundDepositABI,\n            functionName: \"supply\",\n            args: [asset, amountInWei],\n            chainId\n        });\n        success = true;\n        return txHash;\n\n    } catch (err) {\n        return err.message || 'Internal error';\n    }\n}",
  "underlyingAsset": "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
  "yieldBearingToken": "0xd98Be00b5D27fc98112BdE293e487f8D4cA57d07",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68bab394a7e2c8ebb80450df"
  },
  "asset": {
    "$oid": "68b14b6bf55db3d0dfa7df5e"
  },
  "protocol": {
    "$oid": "68bab201a7e2c8ebb80450de"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.llamarpc.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const POOL_ADDRESS = \"0x80ac24aA929eaF5013f6436cdA2a7ba190f5Cc0b\".toLowerCase();\n  const poolABI = [\n    \"function convertToAssets(uint256 shares_) view returns (uint256 assets_)\",\n    \"function decimals() view returns (uint8)\"\n  ];\n  const pool = new ethers.Contract(POOL_ADDRESS, poolABI, provider);\n\n  try {\n    const decimals = await pool.decimals();\n    const ONE_SHARE = ethers.parseUnits(\"1\", decimals);\n\n    const nowBlock = await provider.getBlockNumber();\n    const blockBefore = nowBlock - 7200; // ~1 day ago\n\n    const [assetsNow, assetsBefore] = await Promise.all([\n      pool.convertToAssets(ONE_SHARE, { blockTag: nowBlock }),\n      pool.convertToAssets(ONE_SHARE, { blockTag: blockBefore }),\n    ]);\n\n    const growth = (Number(assetsNow) - Number(assetsBefore)) / Number(assetsBefore);\n    const apy = (Math.pow(1 + growth, 365) - 1) * 100;\n    console.log(`Maple Pool On-Chain Spot APY: ${apy.toFixed(2)}%`);\n    console.log(`Assets Now: ${ethers.formatUnits(assetsNow, decimals)}`);\n    return { apy: apy.toFixed(2) , borrowApy:null, rewardApy:null};\n  } catch (err) {\n    console.error(\"RPC on-chain fetch failed:\", err.message);\n    return { apy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const poolAddress = \"0x80ac24aA929eaF5013f6436cdA2a7ba190f5Cc0b\"; // Maple Pool\n\n  const poolABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"shares\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" }\n      ],\n      name: \"requestRedeem\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    },\n    {\n      inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n      name: \"balanceOf\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    },\n    {\n      inputs: [{ internalType: \"uint256\", name: \"assets\", type: \"uint256\" }],\n      name: \"convertToExitShares\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    // Convert USDC amount  pool shares\n    const amountInWei = parseUnits(amount, tokenDecimals);\n    const shares = await readContractAsync({\n      address: poolAddress,\n      abi: poolABI,\n      functionName: \"convertToExitShares\",\n      args: [amountInWei],\n      chainId\n    });\n\n    // Safety: dont try to withdraw 0\n    if (shares === 0n) throw new Error(\"No shares to withdraw.\");\n\n    // Submit withdrawal request\n    txHash = await writeContractAsync({\n      address: poolAddress,\n      abi: poolABI,\n      functionName: \"requestRedeem\",\n      args: [shares, address],\n      chainId\n    });\n\n    success = true;\n    return txHash;\n  } catch (err) {\n    return err.message || \"Internal error\";\n  }\n}\n",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId, authSig) {\n  const SYRUP_ROUTER_ADDRESS = \"0x134cCaaA4F1e4552eC8aEcb9E4A2360dDcF8df76\"; // replace with actual\n  const USDC_ADDRESS = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"; // USDC mainnet\n  const INTEGRATOR_ID = 1234; // replace with your integratorId\n  const rpcUrl = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n\n  const erc20Abi = [\n    {\n      inputs: [\n        { name: \"owner\", type: \"address\" },\n        { name: \"spender\", type: \"address\" }\n      ],\n      name: \"allowance\",\n      outputs: [{ name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    },\n    {\n      inputs: [\n        { name: \"spender\", type: \"address\" },\n        { name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const syrupRouterAbi = [\n    {\n      inputs: [\n        { name: \"assets\", type: \"uint256\" },\n        { name: \"integratorId\", type: \"uint256\" }\n      ],\n      name: \"deposit\",\n      outputs: [{ name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    },\n    {\n      inputs: [\n        { name: \"bitmap\", type: \"uint256\" },\n        { name: \"deadline\", type: \"uint256\" },\n        { name: \"v\", type: \"uint8\" },\n        { name: \"r\", type: \"bytes32\" },\n        { name: \"s\", type: \"bytes32\" },\n        { name: \"assets\", type: \"uint256\" },\n        { name: \"integratorId\", type: \"uint256\" }\n      ],\n      name: \"authorizeAndDeposit\",\n      outputs: [{ name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // 1. Check allowance\n    const erc20Contract = new ethers.Contract(USDC_ADDRESS, erc20Abi, provider);\n    const allowance = await erc20Contract.allowance(address, SYRUP_ROUTER_ADDRESS);\n\n    // 2. Approve if needed\n    if (BigInt(allowance) < amountInWei) {\n      await writeContractAsync({\n        address: USDC_ADDRESS,\n        abi: erc20Abi,\n        functionName: \"approve\",\n        args: [SYRUP_ROUTER_ADDRESS, amountInWei],\n        chainId\n      });\n    }\n\n    // 3. Deposit\n    if (authSig) {\n      const { bitmap, deadline, v, r, s } = authSig;\n      txHash = await writeContractAsync({\n        address: SYRUP_ROUTER_ADDRESS,\n        abi: syrupRouterAbi,\n        functionName: \"authorizeAndDeposit\",\n        args: [bitmap, deadline, v, r, s, amountInWei, INTEGRATOR_ID],\n        chainId\n      });\n    } else {\n      txHash = await writeContractAsync({\n        address: SYRUP_ROUTER_ADDRESS,\n        abi: syrupRouterAbi,\n        functionName: \"deposit\",\n        args: [amountInWei, INTEGRATOR_ID],\n        chainId\n      });\n    }\n\n    success = true;\n    return txHash;\n\n  } catch (err) {\n    return err.message || \"Internal error\";\n  }\n}",
  "underlyingAsset": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  "yieldBearingToken": "0x80ac24aA929eaF5013f6436cdA2a7ba190f5Cc0b",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68bab594f708dd8416040550"
  },
  "asset": {
    "$oid": "68b14b85f55db3d0dfa7df62"
  },
  "protocol": {
    "$oid": "68bab201a7e2c8ebb80450de"
  },
  "apy": "(async function (ethers) {\n  // RPC provider (must be archive-enabled, e.g. Infura/Alchemy with archive access)\n  const rpcUrl = \"https://eth.llamarpc.com\"; \n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n\n  // Replace with actual Maple USDC pool address\n  const poolAddress = \"0x356B8d89c1e1239Cbbb9dE4815c39A1474d5BA7D\";\n\n  // Minimal ABI for Maple Pool (ERC4626 methods)\n  const poolABI = [\n    {\n      inputs: [{ internalType: \"uint256\", name: \"shares_\", type: \"uint256\" }],\n      name: \"convertToAssets\",\n      outputs: [{ internalType: \"uint256\", name: \"assets_\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      name: \"decimals\",\n      outputs: [{ internalType: \"uint8\", name: \"\", type: \"uint8\" }],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n  ];\n\n  const pool = new ethers.Contract(poolAddress, poolABI, provider);\n\n  try {\n    // Get decimals of pool shares\n    const decimals = await pool.decimals();\n    const ONE_SHARE = ethers.parseUnits(\"1\", decimals);\n\n    // Current and historical blocks\n    const nowBlock = await provider.getBlockNumber();\n    const blockBefore = nowBlock - 7200; // ~1 day ago on Ethereum ( 7200 blocks/day)\n\n    // Assets per share now and 1 day ago\n    const assetsNow = await pool.convertToAssets(ONE_SHARE, { blockTag: nowBlock });\n    const assetsBefore = await pool.convertToAssets(ONE_SHARE, { blockTag: blockBefore });\n\n    // Growth over 1 day\n    const growth =\n      (Number(assetsNow) - Number(assetsBefore)) / Number(assetsBefore);\n\n    // Elapsed time in seconds (1 day here)\n    const elapsed = 24 * 3600;\n\n    // Annualized APY\n    const apy =\n      (Math.pow(1 + growth, (365 * 24 * 3600) / elapsed) - 1) * 100;\n\n    console.log(`Maple USDC Pool APY: ${apy.toFixed(2)}%`);\n\n    return {\n      apy: apy.toFixed(2),\n      borrowApy: \"N/A\",  // Maple doesnt expose borrow APY directly\n      rewardApy: \"N/A\",  // No reward APY like Aave\n    };\n\n  } catch (err) {\n    console.error(\"Error calculating Maple APY:\", err);\n    return err.message || \"Internal error\";\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const poolAddress = \"0x356B8d89c1e1239Cbbb9dE4815c39A1474d5BA7D\"; // Maple Pool\n\n  const poolABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"shares\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" }\n      ],\n      name: \"requestRedeem\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    },\n    {\n      inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n      name: \"balanceOf\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    },\n    {\n      inputs: [{ internalType: \"uint256\", name: \"assets\", type: \"uint256\" }],\n      name: \"convertToExitShares\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    // Convert USDC amount  pool shares\n    const amountInWei = parseUnits(amount, tokenDecimals);\n    const shares = await readContractAsync({\n      address: poolAddress,\n      abi: poolABI,\n      functionName: \"convertToExitShares\",\n      args: [amountInWei],\n      chainId\n    });\n\n    // Safety: dont try to withdraw 0\n    if (shares === 0n) throw new Error(\"No shares to withdraw.\");\n\n    // Submit withdrawal request\n    txHash = await writeContractAsync({\n      address: poolAddress,\n      abi: poolABI,\n      functionName: \"requestRedeem\",\n      args: [shares, address],\n      chainId\n    });\n\n    success = true;\n    return txHash;\n  } catch (err) {\n    return err.message || \"Internal error\";\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId, authSig) {\n  const SYRUP_ROUTER_ADDRESS = \"0xF007476Bb27430795138C511F18F821e8D1e5Ee2\"; // replace with actual\n  const USDC_ADDRESS = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\"; // USDC mainnet\n  const INTEGRATOR_ID = 1234; // replace with your integratorId\n  const rpcUrl = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(rpcUrl);\n\n  const erc20Abi = [\n    {\n      inputs: [\n        { name: \"owner\", type: \"address\" },\n        { name: \"spender\", type: \"address\" }\n      ],\n      name: \"allowance\",\n      outputs: [{ name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    },\n    {\n      inputs: [\n        { name: \"spender\", type: \"address\" },\n        { name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const syrupRouterAbi = [\n    {\n      inputs: [\n        { name: \"assets\", type: \"uint256\" },\n        { name: \"integratorId\", type: \"uint256\" }\n      ],\n      name: \"deposit\",\n      outputs: [{ name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    },\n    {\n      inputs: [\n        { name: \"bitmap\", type: \"uint256\" },\n        { name: \"deadline\", type: \"uint256\" },\n        { name: \"v\", type: \"uint8\" },\n        { name: \"r\", type: \"bytes32\" },\n        { name: \"s\", type: \"bytes32\" },\n        { name: \"assets\", type: \"uint256\" },\n        { name: \"integratorId\", type: \"uint256\" }\n      ],\n      name: \"authorizeAndDeposit\",\n      outputs: [{ name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // 1. Check allowance\n    const erc20Contract = new ethers.Contract(USDC_ADDRESS, erc20Abi, provider);\n    const allowance = await erc20Contract.allowance(address, SYRUP_ROUTER_ADDRESS);\n\n    // 2. Approve if needed\n    if (BigInt(allowance) < amountInWei) {\n      await writeContractAsync({\n        address: USDC_ADDRESS,\n        abi: erc20Abi,\n        functionName: \"approve\",\n        args: [SYRUP_ROUTER_ADDRESS, amountInWei],\n        chainId\n      });\n    }\n\n    // 3. Deposit\n    if (authSig) {\n      const { bitmap, deadline, v, r, s } = authSig;\n      txHash = await writeContractAsync({\n        address: SYRUP_ROUTER_ADDRESS,\n        abi: syrupRouterAbi,\n        functionName: \"authorizeAndDeposit\",\n        args: [bitmap, deadline, v, r, s, amountInWei, INTEGRATOR_ID],\n        chainId\n      });\n    } else {\n      txHash = await writeContractAsync({\n        address: SYRUP_ROUTER_ADDRESS,\n        abi: syrupRouterAbi,\n        functionName: \"deposit\",\n        args: [amountInWei, INTEGRATOR_ID],\n        chainId\n      });\n    }\n\n    success = true;\n    return txHash;\n\n  } catch (err) {\n    return err.message || \"Internal error\";\n  }\n}",
  "underlyingAsset": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
  "yieldBearingToken": "0x356B8d89c1e1239Cbbb9dE4815c39A1474d5BA7D",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68be82b32c43be53109d0683"
  },
  "asset": {
    "$oid": "68b14b6bf55db3d0dfa7df5e"
  },
  "protocol": {
    "$oid": "68be81d22c43be53109d0682"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.llamarpc.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // Hardcoded SparkLend addresses\n  const AAVE_DATA_PROVIDER_ADDRESS = \"0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d\";\n  const TOKEN_ADDRESS = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"; // USDC\n\n  // Aave Data Provider ABI - only the function we need\n  const dataProviderABI = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"asset\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getReserveData\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"availableLiquidity\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalStableDebt\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalVariableDebt\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"liquidityRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"variableBorrowRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"stableBorrowRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"averageStableBorrowRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"liquidityIndex\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"variableBorrowIndex\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint40\",\n        \"name\": \"lastUpdateTimestamp\",\n        \"type\": \"uint40\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }]\n\n\n  const dataProvider = new ethers.Contract(AAVE_DATA_PROVIDER_ADDRESS, dataProviderABI, provider);\n\n  try {\n    // Get reserve data from SparkLend\n    const reserveData = await dataProvider.getReserveData(TOKEN_ADDRESS);\n\n    // Convert raw rates from ray (1e27) to APY\n    // Convert APR (ray, 1e27) to APY\n    function aprToApy(rawRate) {\n      const apr = parseFloat(ethers.formatUnits(rawRate, 27)); // e.g., 0.02 = 2%\n      const apy = (Math.pow(1 + apr / 365, 365) - 1) * 100;   // daily compounding\n      return apy.toFixed(2);\n    }\n\n    const supplyApy = aprToApy(reserveData.liquidityRate);\n    const borrowApy = aprToApy(reserveData.variableBorrowRate);\n\n    console.log(`SparkLend USDC Supply APY: ${supplyApy}%`);\n    console.log(`SparkLend USDC Borrow APY: ${borrowApy}%`);\n\n    return {\n      apy: supplyApy,\n      borrowApy: borrowApy,\n      rewardApy: null\n    };\n\n  } catch (err) {\n    console.error(\"RPC on-chain fetch failed:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const poolAddress = \"0xC13e21B648A5Ee794902342038FF3aDAB66BE987\"; // SparkLend Pool\n  const usdcAddress = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"; // USDC\n\n  const poolABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    // Convert amount to wei (use MaxUint256 for full withdrawal)\n    const amountInWei = amount === \"max\" \n      ? ethers.MaxUint256 \n      : parseUnits(amount, tokenDecimals);\n\n    // Safety: don't try to withdraw 0\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw from SparkLend\n    txHash = await writeContractAsync({\n      address: poolAddress,\n      abi: poolABI,\n      functionName: \"withdraw\",\n      args: [usdcAddress, amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Internal error\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const poolAddress = \"0xC13e21B648A5Ee794902342038FF3aDAB66BE987\"; // SparkLend Pool\n  const usdcAddress = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"; // USDC\n\n  const poolABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" }\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    // Convert amount to wei\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // First, approve the pool to spend USDC\n    const approveTx = await writeContractAsync({\n      address: usdcAddress,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [poolAddress, amountInWei],\n      chainId\n    });\n\n    // Wait for approval to confirm\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Then, deposit into SparkLend\n    txHash = await writeContractAsync({\n      address: poolAddress,\n      abi: poolABI,\n      functionName: \"supply\",\n      args: [usdcAddress, amountInWei, address, 0], // referralCode = 0\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Internal error\" };\n  }\n}",
  "underlyingAsset": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  "yieldBearingToken": "0xBc65ad17c5C0a2A4D159fa5a503f4992c7B545FE",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68be8b7a107af75b8f83d586"
  },
  "asset": {
    "$oid": "68b14b85f55db3d0dfa7df62"
  },
  "protocol": {
    "$oid": "68be81d22c43be53109d0682"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.llamarpc.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // Hardcoded SparkLend addresses\n  const AAVE_DATA_PROVIDER_ADDRESS = \"0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d\";\n  const TOKEN_ADDRESS = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\"; \n\n  // Aave Data Provider ABI - only the function we need\n  const dataProviderABI = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"asset\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getReserveData\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"availableLiquidity\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalStableDebt\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalVariableDebt\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"liquidityRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"variableBorrowRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"stableBorrowRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"averageStableBorrowRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"liquidityIndex\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"variableBorrowIndex\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint40\",\n        \"name\": \"lastUpdateTimestamp\",\n        \"type\": \"uint40\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }]\n\n\n  const dataProvider = new ethers.Contract(AAVE_DATA_PROVIDER_ADDRESS, dataProviderABI, provider);\n\n  try {\n    // Get reserve data from SparkLend\n    const reserveData = await dataProvider.getReserveData(TOKEN_ADDRESS);\n\n    // Convert raw rates from ray (1e27) to APY\n    // Convert APR (ray, 1e27) to APY\n    function aprToApy(rawRate) {\n      const apr = parseFloat(ethers.formatUnits(rawRate, 27)); // e.g., 0.02 = 2%\n      const apy = (Math.pow(1 + apr / 365, 365) - 1) * 100;   // daily compounding\n      return apy.toFixed(2);\n    }\n\n    const supplyApy = aprToApy(reserveData.liquidityRate);\n    const borrowApy = aprToApy(reserveData.variableBorrowRate);\n\n    console.log(`SparkLend USDC Supply APY: ${supplyApy}%`);\n    console.log(`SparkLend USDC Borrow APY: ${borrowApy}%`);\n\n    return {\n      apy: supplyApy,\n      borrowApy: borrowApy,\n      rewardApy: null\n    };\n\n  } catch (err) {\n    console.error(\"RPC on-chain fetch failed:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const poolAddress = \"0xC13e21B648A5Ee794902342038FF3aDAB66BE987\"; // SparkLend Pool\n  const usdcAddress = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\"; \n\n  const poolABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    // Convert amount to wei (use MaxUint256 for full withdrawal)\n    const amountInWei = amount === \"max\"\n      ? ethers.MaxUint256\n      : parseUnits(amount, tokenDecimals);\n\n    // Safety: don't try to withdraw 0\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw from SparkLend\n    txHash = await writeContractAsync({\n      address: poolAddress,\n      abi: poolABI,\n      functionName: \"withdraw\",\n      args: [usdcAddress, amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Internal error\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const poolAddress = \"0xC13e21B648A5Ee794902342038FF3aDAB66BE987\"; // SparkLend Pool\n  const usdcAddress = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\"; \n\n  const poolABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" }\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    // Convert amount to wei\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // First, approve the pool to spend USDC\n    const approveTx = await writeContractAsync({\n      address: usdcAddress,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [poolAddress, amountInWei],\n      chainId\n    });\n\n    // Wait for approval to confirm\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Then, deposit into SparkLend\n    txHash = await writeContractAsync({\n      address: poolAddress,\n      abi: poolABI,\n      functionName: \"supply\",\n      args: [usdcAddress, amountInWei, address, 0], // referralCode = 0\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Internal error\" };\n  }\n}",
  "underlyingAsset": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
  "yieldBearingToken": "0xC13e21B648A5Ee794902342038FF3aDAB66BE987",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68be8cb4107af75b8f83d587"
  },
  "asset": {
    "$oid": "68b14c95f55db3d0dfa7df70"
  },
  "protocol": {
    "$oid": "68be81d22c43be53109d0682"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.llamarpc.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // Hardcoded SparkLend addresses\n  const AAVE_DATA_PROVIDER_ADDRESS = \"0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d\";\n  const TOKEN_ADDRESS = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"; \n\n  // Aave Data Provider ABI - only the function we need\n  const dataProviderABI = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"asset\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getReserveData\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"availableLiquidity\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalStableDebt\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalVariableDebt\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"liquidityRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"variableBorrowRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"stableBorrowRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"averageStableBorrowRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"liquidityIndex\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"variableBorrowIndex\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint40\",\n        \"name\": \"lastUpdateTimestamp\",\n        \"type\": \"uint40\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }]\n\n\n  const dataProvider = new ethers.Contract(AAVE_DATA_PROVIDER_ADDRESS, dataProviderABI, provider);\n\n  try {\n    // Get reserve data from SparkLend\n    const reserveData = await dataProvider.getReserveData(TOKEN_ADDRESS);\n\n    // Convert raw rates from ray (1e27) to APY\n    // Convert APR (ray, 1e27) to APY\n    function aprToApy(rawRate) {\n      const apr = parseFloat(ethers.formatUnits(rawRate, 27)); // e.g., 0.02 = 2%\n      const apy = (Math.pow(1 + apr / 365, 365) - 1) * 100;   // daily compounding\n      return apy.toFixed(2);\n    }\n\n    const supplyApy = aprToApy(reserveData.liquidityRate);\n    const borrowApy = aprToApy(reserveData.variableBorrowRate);\n\n    console.log(`SparkLend USDC Supply APY: ${supplyApy}%`);\n    console.log(`SparkLend USDC Borrow APY: ${borrowApy}%`);\n\n    return {\n      apy: supplyApy,\n      borrowApy: borrowApy,\n      rewardApy: null\n    };\n\n  } catch (err) {\n    console.error(\"RPC on-chain fetch failed:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const poolAddress = \"0xC13e21B648A5Ee794902342038FF3aDAB66BE987\"; // SparkLend Pool\n  const usdcAddress = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"; \n\n  const poolABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    // Convert amount to wei (use MaxUint256 for full withdrawal)\n    const amountInWei = amount === \"max\"\n      ? ethers.MaxUint256\n      : parseUnits(amount, tokenDecimals);\n\n    // Safety: don't try to withdraw 0\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw from SparkLend\n    txHash = await writeContractAsync({\n      address: poolAddress,\n      abi: poolABI,\n      functionName: \"withdraw\",\n      args: [usdcAddress, amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Internal error\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const poolAddress = \"0xC13e21B648A5Ee794902342038FF3aDAB66BE987\"; // SparkLend Pool\n  const usdcAddress = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"; \n\n  const poolABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" }\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    // Convert amount to wei\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // First, approve the pool to spend USDC\n    const approveTx = await writeContractAsync({\n      address: usdcAddress,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [poolAddress, amountInWei],\n      chainId\n    });\n\n    // Wait for approval to confirm\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Then, deposit into SparkLend\n    txHash = await writeContractAsync({\n      address: poolAddress,\n      abi: poolABI,\n      functionName: \"supply\",\n      args: [usdcAddress, amountInWei, address, 0], // referralCode = 0\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Internal error\" };\n  }\n}",
  "underlyingAsset": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
  "yieldBearingToken": "0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68be9c45934375ffebd144f0"
  },
  "asset": {
    "$oid": "68b14c85f55db3d0dfa7df6f"
  },
  "protocol": {
    "$oid": "68be81d22c43be53109d0682"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.llamarpc.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // Hardcoded SparkLend addresses\n  const AAVE_DATA_PROVIDER_ADDRESS = \"0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d\";\n  const TOKEN_ADDRESS = \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\"; \n\n  // Aave Data Provider ABI - only the function we need\n  const dataProviderABI = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"asset\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getReserveData\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"availableLiquidity\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalStableDebt\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalVariableDebt\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"liquidityRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"variableBorrowRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"stableBorrowRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"averageStableBorrowRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"liquidityIndex\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"variableBorrowIndex\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint40\",\n        \"name\": \"lastUpdateTimestamp\",\n        \"type\": \"uint40\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }]\n\n\n  const dataProvider = new ethers.Contract(AAVE_DATA_PROVIDER_ADDRESS, dataProviderABI, provider);\n\n  try {\n    // Get reserve data from SparkLend\n    const reserveData = await dataProvider.getReserveData(TOKEN_ADDRESS);\n\n    // Convert raw rates from ray (1e27) to APY\n    // Convert APR (ray, 1e27) to APY\n    function aprToApy(rawRate) {\n      const apr = parseFloat(ethers.formatUnits(rawRate, 27)); // e.g., 0.02 = 2%\n      const apy = (Math.pow(1 + apr / 365, 365) - 1) * 100;   // daily compounding\n      return apy.toFixed(2);\n    }\n\n    const supplyApy = aprToApy(reserveData.liquidityRate);\n    const borrowApy = aprToApy(reserveData.variableBorrowRate);\n\n    console.log(`SparkLend USDC Supply APY: ${supplyApy}%`);\n    console.log(`SparkLend USDC Borrow APY: ${borrowApy}%`);\n\n    return {\n      apy: supplyApy,\n      borrowApy: borrowApy,\n      rewardApy: null\n    };\n\n  } catch (err) {\n    console.error(\"RPC on-chain fetch failed:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const poolAddress = \"0xC13e21B648A5Ee794902342038FF3aDAB66BE987\"; // SparkLend Pool\n  const usdcAddress = \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\"; \n\n  const poolABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    // Convert amount to wei (use MaxUint256 for full withdrawal)\n    const amountInWei = amount === \"max\"\n      ? ethers.MaxUint256\n      : parseUnits(amount, tokenDecimals);\n\n    // Safety: don't try to withdraw 0\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw from SparkLend\n    txHash = await writeContractAsync({\n      address: poolAddress,\n      abi: poolABI,\n      functionName: \"withdraw\",\n      args: [usdcAddress, amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Internal error\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const poolAddress = \"0xC13e21B648A5Ee794902342038FF3aDAB66BE987\"; // SparkLend Pool\n  const usdcAddress = \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\"; \n\n  const poolABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" }\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    // Convert amount to wei\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // First, approve the pool to spend USDC\n    const approveTx = await writeContractAsync({\n      address: usdcAddress,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [poolAddress, amountInWei],\n      chainId\n    });\n\n    // Wait for approval to confirm\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Then, deposit into SparkLend\n    txHash = await writeContractAsync({\n      address: poolAddress,\n      abi: poolABI,\n      functionName: \"supply\",\n      args: [usdcAddress, amountInWei, address, 0], // referralCode = 0\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Internal error\" };\n  }\n}",
  "underlyingAsset": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  "yieldBearingToken": "0xC13e21B648A5Ee794902342038FF3aDAB66BE987",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68be9e5d934375ffebd144f2"
  },
  "asset": {
    "$oid": "68b14cd8f55db3d0dfa7df75"
  },
  "protocol": {
    "$oid": "68be81d22c43be53109d0682"
  },
  "apy": "(async function (ethers) {\n const RPC_URL = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const AAVE_DATA_PROVIDER_ADDRESS = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\"; // DataProvider (Arbitrum)\n  const USDC_ADDRESS = \"0xaf88d065e77c8cC2239327C5EDb3A432268e5831\";            // USDC (Arbitrum)\n\n  const dataProviderABI = [{\n    \"inputs\": [{ \"internalType\": \"address\", \"name\": \"asset\", \"type\": \"address\" }],\n    \"name\": \"getReserveData\",\n    \"outputs\": [\n      { \"internalType\": \"uint256\", \"name\": \"availableLiquidity\", \"type\": \"uint256\" },\n      { \"internalType\": \"uint256\", \"name\": \"totalStableDebt\", \"type\": \"uint256\" },\n      { \"internalType\": \"uint256\", \"name\": \"totalVariableDebt\", \"type\": \"uint256\" },\n      { \"internalType\": \"uint256\", \"name\": \"liquidityRate\", \"type\": \"uint256\" },\n      { \"internalType\": \"uint256\", \"name\": \"variableBorrowRate\", \"type\": \"uint256\" },\n      { \"internalType\": \"uint256\", \"name\": \"stableBorrowRate\", \"type\": \"uint256\" },\n      { \"internalType\": \"uint256\", \"name\": \"averageStableBorrowRate\", \"type\": \"uint256\" },\n      { \"internalType\": \"uint256\", \"name\": \"liquidityIndex\", \"type\": \"uint256\" },\n      { \"internalType\": \"uint256\", \"name\": \"variableBorrowIndex\", \"type\": \"uint256\" },\n      { \"internalType\": \"uint40\", \"name\": \"lastUpdateTimestamp\", \"type\": \"uint40\" }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }];\n\n  const dataProvider = new ethers.Contract(AAVE_DATA_PROVIDER_ADDRESS, dataProviderABI, provider);\n  const reserveData = await dataProvider.getReserveData(USDC_ADDRESS);\n\n  function aprToApy(rawRate) {\n    const apr = parseFloat(ethers.formatUnits(rawRate, 27));\n    const apy = (Math.pow(1 + apr / 365, 365) - 1) * 100; // daily compounding\n    return apy.toFixed(2);\n  }\n\n  const supplyApy = aprToApy(reserveData.liquidityRate);\n  const borrowApy = aprToApy(reserveData.variableBorrowRate);\n\n  console.log(`SparkLend USDC Supply APY (Arbitrum): ${supplyApy}%`);\n  console.log(`SparkLend USDC Borrow APY (Arbitrum): ${borrowApy}%`);\n\n  return { apy: supplyApy, borrowApy, rewardApy: null };\n});\n",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const POOL_ADDRESS = \"0xC13e21B648A5Ee794902342038FF3aDAB66BE987\";           // Pool (Arbitrum)\n  const USDC_ADDRESS = \"0xaf88d065e77c8cC2239327C5EDb3A432268e5831\";            // USDC (Arbitrum)\n\n  const poolABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = amount === \"max\"\n      ? ethers.MaxUint256\n      : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    txHash = await writeContractAsync({\n      address: POOL_ADDRESS,\n      abi: poolABI,\n      functionName: \"withdraw\",\n      args: [USDC_ADDRESS, amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const POOL_ADDRESS = \"0xC13e21B648A5Ee794902342038FF3aDAB66BE987\";           // Pool (Arbitrum)\n  const USDC_ADDRESS = \"0xaf88d065e77c8cC2239327C5EDb3A432268e5831\";            // USDC (Arbitrum)\n\n  const poolABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" }\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Pool to spend USDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [POOL_ADDRESS, amountInWei],\n      chainId\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Supply USDC\n    txHash = await writeContractAsync({\n      address: POOL_ADDRESS,\n      abi: poolABI,\n      functionName: \"supply\",\n      args: [USDC_ADDRESS, amountInWei, address, 0],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
  "yieldBearingToken": "0xC13e21B648A5Ee794902342038FF3aDAB66BE987",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68beaf506f8a85b3ca5080a5"
  },
  "asset": {
    "$oid": "68b14b6bf55db3d0dfa7df5e"
  },
  "protocol": {
    "$oid": "68beaee36f8a85b3ca5080a4"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const EULER_VAULT_ADDRESS = \"0xe0a80d35bB6618CBA260120b279d357978c42BCE\";\n\n  // Minimal ABI: only need interestRate()\n  const eVaultABI = [\n    {\n      \"inputs\": [],\n      \"name\": \"interestRate\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    }\n  ];\n\n  const vault = new ethers.Contract(EULER_VAULT_ADDRESS, eVaultABI, provider);\n\n  try {\n    // Fetch per-second interest rate (in ray, 1e27)\n    const rawRate = await vault.interestRate();\n\n    // Convert APR  APY\n    function aprToApy(rateRay) {\n      const apr = parseFloat(ethers.formatUnits(rateRay, 27)); // per second rate\n      const secondsPerYear = 60 * 60 * 24 * 365;\n      const apy = (Math.pow(1 + apr, secondsPerYear) - 1) * 100;\n      return apy.toFixed(2);\n    }\n\n    const supplyApy = aprToApy(rawRate);\n\n    console.log(`Euler Vault (${EULER_VAULT_ADDRESS}) Supply APY: ${supplyApy}%`);\n\n    return {\n      apy: supplyApy,\n      borrowApy: null,   // Euler tracks borrow separately if needed\n      rewardApy: null\n    };\n\n  } catch (err) {\n    console.error(\"Error fetching Euler APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});\n",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0xe0a80d35bB6618CBA260120b279d357978c42BCE\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" },\n        { internalType: \"address\", name: \"owner\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = amount === \"max\"\n      ? MaxUint256\n      : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw from Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"withdraw\",\n      args: [amountInWei, address, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0xe0a80d35bB6618CBA260120b279d357978c42BCE\"; \n  const USDC_ADDRESS  = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" }\n      ],\n      name: \"deposit\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Vault to spend USDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [VAULT_ADDRESS, amountInWei],\n      chainId\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit USDC into Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"deposit\",\n      args: [amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  "yieldBearingToken": "0xe0a80d35bB6618CBA260120b279d357978c42BCE",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68bfc328b968c7f33e7d4052"
  },
  "asset": {
    "$oid": "68b14b85f55db3d0dfa7df62"
  },
  "protocol": {
    "$oid": "68beaee36f8a85b3ca5080a4"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\"; // Arbitrum RPC\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // Hardcoded Euler vault (example: USDC vault on Arbitrum)\n  const EULER_VAULT_ADDRESS = \"0x7c280DBDEf569e96c7919251bD2B0edF0734C5A8\";\n\n  // Minimal ABI: only need interestRate()\n  const eVaultABI = [\n    {\n      \"inputs\": [],\n      \"name\": \"interestRate\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    }\n  ];\n\n  const vault = new ethers.Contract(EULER_VAULT_ADDRESS, eVaultABI, provider);\n\n  try {\n    // Fetch per-second interest rate (in ray, 1e27)\n    const rawRate = await vault.interestRate();\n\n    // Convert APR  APY\n    function aprToApy(rateRay) {\n      const apr = parseFloat(ethers.formatUnits(rateRay, 27)); // per second rate\n      const secondsPerYear = 60 * 60 * 24 * 365;\n      const apy = (Math.pow(1 + apr, secondsPerYear) - 1) * 100;\n      return apy.toFixed(2);\n    }\n\n    const supplyApy = aprToApy(rawRate);\n\n    console.log(`Euler Vault (${EULER_VAULT_ADDRESS}) Supply APY: ${supplyApy}%`);\n\n    return {\n      apy: supplyApy,\n      borrowApy: null,   // Euler tracks borrow separately if needed\n      rewardApy: null\n    };\n\n  } catch (err) {\n    console.error(\"Error fetching Euler APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});\n",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0x7c280DBDEf569e96c7919251bD2B0edF0734C5A8\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" },\n        { internalType: \"address\", name: \"owner\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = amount === \"max\"\n      ? MaxUint256\n      : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw from Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"withdraw\",\n      args: [amountInWei, address, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0x7c280DBDEf569e96c7919251bD2B0edF0734C5A8\"; \n  const USDC_ADDRESS  = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" }\n      ],\n      name: \"deposit\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Vault to spend USDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [VAULT_ADDRESS, amountInWei],\n      chainId\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit USDC into Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"deposit\",\n      args: [amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
  "yieldBearingToken": "0x7c280DBDEf569e96c7919251bD2B0edF0734C5A8",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68bfc4a5e8bb7a6698ff8297"
  },
  "asset": {
    "$oid": "68b14c85f55db3d0dfa7df6f"
  },
  "protocol": {
    "$oid": "68beaee36f8a85b3ca5080a4"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\"; // Arbitrum RPC\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // Hardcoded Euler vault (example: USDC vault on Arbitrum)\n  const EULER_VAULT_ADDRESS = \"0xD8b27CF359b7D15710a5BE299AF6e7Bf904984C2\";\n\n  // Minimal ABI: only need interestRate()\n  const eVaultABI = [\n    {\n      \"inputs\": [],\n      \"name\": \"interestRate\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    }\n  ];\n\n  const vault = new ethers.Contract(EULER_VAULT_ADDRESS, eVaultABI, provider);\n\n  try {\n    // Fetch per-second interest rate (in ray, 1e27)\n    const rawRate = await vault.interestRate();\n\n    // Convert APR  APY\n    function aprToApy(rateRay) {\n      const apr = parseFloat(ethers.formatUnits(rateRay, 27)); // per second rate\n      const secondsPerYear = 60 * 60 * 24 * 365;\n      const apy = (Math.pow(1 + apr, secondsPerYear) - 1) * 100;\n      return apy.toFixed(2);\n    }\n\n    const supplyApy = aprToApy(rawRate);\n\n    console.log(`Euler Vault (${EULER_VAULT_ADDRESS}) Supply APY: ${supplyApy}%`);\n\n    return {\n      apy: supplyApy,\n      borrowApy: null,   // Euler tracks borrow separately if needed\n      rewardApy: null\n    };\n\n  } catch (err) {\n    console.error(\"Error fetching Euler APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0xD8b27CF359b7D15710a5BE299AF6e7Bf904984C2\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" },\n        { internalType: \"address\", name: \"owner\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = amount === \"max\"\n      ? MaxUint256\n      : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw from Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"withdraw\",\n      args: [amountInWei, address, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0xD8b27CF359b7D15710a5BE299AF6e7Bf904984C2\"; \n  const USDC_ADDRESS  = \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" }\n      ],\n      name: \"deposit\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Vault to spend USDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [VAULT_ADDRESS, amountInWei],\n      chainId\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit USDC into Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"deposit\",\n      args: [amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  "yieldBearingToken": "0xD8b27CF359b7D15710a5BE299AF6e7Bf904984C2",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68bfc5e1e8bb7a6698ff8299"
  },
  "asset": {
    "$oid": "68b14c95f55db3d0dfa7df70"
  },
  "protocol": {
    "$oid": "68beaee36f8a85b3ca5080a4"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\"; // Arbitrum RPC\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // Hardcoded Euler vault (example: USDC vault on Arbitrum)\n  const EULER_VAULT_ADDRESS = \"0x83C266bdf990574a05EE62831a266a3891817B5B\";\n\n  // Minimal ABI: only need interestRate()\n  const eVaultABI = [\n    {\n      \"inputs\": [],\n      \"name\": \"interestRate\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    }\n  ];\n\n  const vault = new ethers.Contract(EULER_VAULT_ADDRESS, eVaultABI, provider);\n\n  try {\n    // Fetch per-second interest rate (in ray, 1e27)\n    const rawRate = await vault.interestRate();\n\n    // Convert APR  APY\n    function aprToApy(rateRay) {\n      const apr = parseFloat(ethers.formatUnits(rateRay, 27)); // per second rate\n      const secondsPerYear = 60 * 60 * 24 * 365;\n      const apy = (Math.pow(1 + apr, secondsPerYear) - 1) * 100;\n      return apy.toFixed(2);\n    }\n\n    const supplyApy = aprToApy(rawRate);\n\n    console.log(`Euler Vault (${EULER_VAULT_ADDRESS}) Supply APY: ${supplyApy}%`);\n\n    return {\n      apy: supplyApy,\n      borrowApy: null,   // Euler tracks borrow separately if needed\n      rewardApy: null\n    };\n\n  } catch (err) {\n    console.error(\"Error fetching Euler APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});\n",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0x83C266bdf990574a05EE62831a266a3891817B5B\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" },\n        { internalType: \"address\", name: \"owner\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = amount === \"max\"\n      ? MaxUint256\n      : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw from Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"withdraw\",\n      args: [amountInWei, address, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0x83C266bdf990574a05EE62831a266a3891817B5B\"; \n  const USDC_ADDRESS  = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" }\n      ],\n      name: \"deposit\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Vault to spend USDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [VAULT_ADDRESS, amountInWei],\n      chainId\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit USDC into Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"deposit\",\n      args: [amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
  "yieldBearingToken": "0x83C266bdf990574a05EE62831a266a3891817B5B",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68bfc80ee8bb7a6698ff829b"
  },
  "asset": {
    "$oid": "68b14cd8f55db3d0dfa7df75"
  },
  "protocol": {
    "$oid": "68beaee36f8a85b3ca5080a4"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://arb1.arbitrum.io/rpc\"; // Arbitrum RPC\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // Hardcoded Euler vault (example: USDC vault on Arbitrum)\n  const EULER_VAULT_ADDRESS = \"0x05d28A86E057364F6ad1a88944297E58Fc6160b3\";\n\n  // Minimal ABI: only need interestRate()\n  const eVaultABI = [\n    {\n      \"inputs\": [],\n      \"name\": \"interestRate\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    }\n  ];\n\n  const vault = new ethers.Contract(EULER_VAULT_ADDRESS, eVaultABI, provider);\n\n  try {\n    // Fetch per-second interest rate (in ray, 1e27)\n    const rawRate = await vault.interestRate();\n\n    // Convert APR  APY\n    function aprToApy(rateRay) {\n      const apr = parseFloat(ethers.formatUnits(rateRay, 27)); // per second rate\n      const secondsPerYear = 60 * 60 * 24 * 365;\n      const apy = (Math.pow(1 + apr, secondsPerYear) - 1) * 100;\n      return apy.toFixed(2);\n    }\n\n    const supplyApy = aprToApy(rawRate);\n\n    console.log(`Euler Vault (${EULER_VAULT_ADDRESS}) Supply APY: ${supplyApy}%`);\n\n    return {\n      apy: supplyApy,\n      borrowApy: null,   // Euler tracks borrow separately if needed\n      rewardApy: null\n    };\n\n  } catch (err) {\n    console.error(\"Error fetching Euler APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0x05d28A86E057364F6ad1a88944297E58Fc6160b3\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" },\n        { internalType: \"address\", name: \"owner\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = amount === \"max\"\n      ? MaxUint256\n      : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw from Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"withdraw\",\n      args: [amountInWei, address, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0x05d28A86E057364F6ad1a88944297E58Fc6160b3\"; \n  const USDC_ADDRESS  = \"0xaf88d065e77c8cC2239327C5EDb3A432268e5831\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" }\n      ],\n      name: \"deposit\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Vault to spend USDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [VAULT_ADDRESS, amountInWei],\n      chainId\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit USDC into Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"deposit\",\n      args: [amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
  "yieldBearingToken": "0x05d28A86E057364F6ad1a88944297E58Fc6160b3",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68bfcc11e8bb7a6698ff829d"
  },
  "asset": {
    "$oid": "68b14cf4f55db3d0dfa7df7a"
  },
  "protocol": {
    "$oid": "68beaee36f8a85b3ca5080a4"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://arb1.arbitrum.io/rpc\"; // Arbitrum RPC\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // Hardcoded Euler vault (example: USDC vault on Arbitrum)\n  const EULER_VAULT_ADDRESS = \"0x78E3E051D32157AACD550fBB78458762d8f7edFF\";\n\n  // Minimal ABI: only need interestRate()\n  const eVaultABI = [\n    {\n      \"inputs\": [],\n      \"name\": \"interestRate\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    }\n  ];\n\n  const vault = new ethers.Contract(EULER_VAULT_ADDRESS, eVaultABI, provider);\n\n  try {\n    // Fetch per-second interest rate (in ray, 1e27)\n    const rawRate = await vault.interestRate();\n\n    // Convert APR  APY\n    function aprToApy(rateRay) {\n      const apr = parseFloat(ethers.formatUnits(rateRay, 27)); // per second rate\n      const secondsPerYear = 60 * 60 * 24 * 365;\n      const apy = (Math.pow(1 + apr, secondsPerYear) - 1) * 100;\n      return apy.toFixed(2);\n    }\n\n    const supplyApy = aprToApy(rawRate);\n\n    console.log(`Euler Vault (${EULER_VAULT_ADDRESS}) Supply APY: ${supplyApy}%`);\n\n    return {\n      apy: supplyApy,\n      borrowApy: null,   // Euler tracks borrow separately if needed\n      rewardApy: null\n    };\n\n  } catch (err) {\n    console.error(\"Error fetching Euler APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0x78E3E051D32157AACD550fBB78458762d8f7edFF\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" },\n        { internalType: \"address\", name: \"owner\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = amount === \"max\"\n      ? MaxUint256\n      : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw from Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"withdraw\",\n      args: [amountInWei, address, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0x78E3E051D32157AACD550fBB78458762d8f7edFF\"; \n  const USDC_ADDRESS  = \"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" }\n      ],\n      name: \"deposit\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Vault to spend USDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [VAULT_ADDRESS, amountInWei],\n      chainId\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit USDC into Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"deposit\",\n      args: [amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
  "yieldBearingToken": "0x78E3E051D32157AACD550fBB78458762d8f7edFF",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68bfcdf8e8bb7a6698ff829f"
  },
  "asset": {
    "$oid": "68af071df48122df91aa93b1"
  },
  "protocol": {
    "$oid": "68beaee36f8a85b3ca5080a4"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://bsc-rpc.publicnode.com\"; // Arbitrum RPC\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // Hardcoded Euler vault (example: USDC vault on Arbitrum)\n  const EULER_VAULT_ADDRESS = \"0xCB9c9FE7d1509955d8b860E6831d91bf3F0B6240\";\n\n  // Minimal ABI: only need interestRate()\n  const eVaultABI = [\n    {\n      \"inputs\": [],\n      \"name\": \"interestRate\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    }\n  ];\n\n  const vault = new ethers.Contract(EULER_VAULT_ADDRESS, eVaultABI, provider);\n\n  try {\n    // Fetch per-second interest rate (in ray, 1e27)\n    const rawRate = await vault.interestRate();\n\n    // Convert APR  APY\n    function aprToApy(rateRay) {\n      const apr = parseFloat(ethers.formatUnits(rateRay, 27)); // per second rate\n      const secondsPerYear = 60 * 60 * 24 * 365;\n      const apy = (Math.pow(1 + apr, secondsPerYear) - 1) * 100;\n      return apy.toFixed(2);\n    }\n\n    const supplyApy = aprToApy(rawRate);\n\n    console.log(`Euler Vault (${EULER_VAULT_ADDRESS}) Supply APY: ${supplyApy}%`);\n\n    return {\n      apy: supplyApy,\n      borrowApy: null,   // Euler tracks borrow separately if needed\n      rewardApy: null\n    };\n\n  } catch (err) {\n    console.error(\"Error fetching Euler APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0xCB9c9FE7d1509955d8b860E6831d91bf3F0B6240\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" },\n        { internalType: \"address\", name: \"owner\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = amount === \"max\"\n      ? MaxUint256\n      : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw from Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"withdraw\",\n      args: [amountInWei, address, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0xCB9c9FE7d1509955d8b860E6831d91bf3F0B6240\"; \n  const USDC_ADDRESS  = \"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" }\n      ],\n      name: \"deposit\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Vault to spend USDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [VAULT_ADDRESS, amountInWei],\n      chainId\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit USDC into Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"deposit\",\n      args: [amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d",
  "yieldBearingToken": "0xCB9c9FE7d1509955d8b860E6831d91bf3F0B6240",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68bfd419e8bb7a6698ff82a1"
  },
  "asset": {
    "$oid": "68b14ac3f55db3d0dfa7df53"
  },
  "protocol": {
    "$oid": "68beaee36f8a85b3ca5080a4"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://bsc-rpc.publicnode.com\"; // Arbitrum RPC\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // Hardcoded Euler vault (example: USDC vault on Arbitrum)\n  const EULER_VAULT_ADDRESS = \"0x69A93DbAB609266af96f05658b2e22d020de2E19\";\n\n  // Minimal ABI: only need interestRate()\n  const eVaultABI = [\n    {\n      \"inputs\": [],\n      \"name\": \"interestRate\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    }\n  ];\n\n  const vault = new ethers.Contract(EULER_VAULT_ADDRESS, eVaultABI, provider);\n\n  try {\n    // Fetch per-second interest rate (in ray, 1e27)\n    const rawRate = await vault.interestRate();\n\n    // Convert APR  APY\n    function aprToApy(rateRay) {\n      const apr = parseFloat(ethers.formatUnits(rateRay, 27)); // per second rate\n      const secondsPerYear = 60 * 60 * 24 * 365;\n      const apy = (Math.pow(1 + apr, secondsPerYear) - 1) * 100;\n      return apy.toFixed(2);\n    }\n\n    const supplyApy = aprToApy(rawRate);\n\n    console.log(`Euler Vault (${EULER_VAULT_ADDRESS}) Supply APY: ${supplyApy}%`);\n\n    return {\n      apy: supplyApy,\n      borrowApy: null,   // Euler tracks borrow separately if needed\n      rewardApy: null\n    };\n\n  } catch (err) {\n    console.error(\"Error fetching Euler APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0x69A93DbAB609266af96f05658b2e22d020de2E19\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" },\n        { internalType: \"address\", name: \"owner\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = amount === \"max\"\n      ? MaxUint256\n      : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw from Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"withdraw\",\n      args: [amountInWei, address, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0x69A93DbAB609266af96f05658b2e22d020de2E19\"; \n  const USDC_ADDRESS  = \"0x55d398326f99059fF775485246999027B3197955\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" }\n      ],\n      name: \"deposit\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Vault to spend USDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [VAULT_ADDRESS, amountInWei],\n      chainId\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit USDC into Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"deposit\",\n      args: [amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x55d398326f99059fF775485246999027B3197955",
  "yieldBearingToken": "0x69A93DbAB609266af96f05658b2e22d020de2E19",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68bfd58fe8bb7a6698ff82a3"
  },
  "asset": {
    "$oid": "68b0349ae0d13595b429a253"
  },
  "protocol": {
    "$oid": "68beaee36f8a85b3ca5080a4"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://bsc-rpc.publicnode.com\"; // Arbitrum RPC\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // Hardcoded Euler vault (example: USDC vault on Arbitrum)\n  const EULER_VAULT_ADDRESS = \"0x3ac88AfbC38Bb41443457eeB027b60e85B815538\";\n\n  // Minimal ABI: only need interestRate()\n  const eVaultABI = [\n    {\n      \"inputs\": [],\n      \"name\": \"interestRate\",\n      \"outputs\": [{ \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" }],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    }\n  ];\n\n  const vault = new ethers.Contract(EULER_VAULT_ADDRESS, eVaultABI, provider);\n\n  try {\n    // Fetch per-second interest rate (in ray, 1e27)\n    const rawRate = await vault.interestRate();\n\n    // Convert APR  APY\n    function aprToApy(rateRay) {\n      const apr = parseFloat(ethers.formatUnits(rateRay, 27)); // per second rate\n      const secondsPerYear = 60 * 60 * 24 * 365;\n      const apy = (Math.pow(1 + apr, secondsPerYear) - 1) * 100;\n      return apy.toFixed(2);\n    }\n\n    const supplyApy = aprToApy(rawRate);\n\n    console.log(`Euler Vault (${EULER_VAULT_ADDRESS}) Supply APY: ${supplyApy}%`);\n\n    return {\n      apy: supplyApy,\n      borrowApy: null,   // Euler tracks borrow separately if needed\n      rewardApy: null\n    };\n\n  } catch (err) {\n    console.error(\"Error fetching Euler APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0x3ac88AfbC38Bb41443457eeB027b60e85B815538\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" },\n        { internalType: \"address\", name: \"owner\", type: \"address\" }\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = amount === \"max\"\n      ? MaxUint256\n      : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw from Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"withdraw\",\n      args: [amountInWei, address, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const VAULT_ADDRESS = \"0x3ac88AfbC38Bb41443457eeB027b60e85B815538\"; \n  const USDC_ADDRESS  = \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\"; \n\n  const vaultABI = [\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n        { internalType: \"address\", name: \"receiver\", type: \"address\" }\n      ],\n      name: \"deposit\",\n      outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const erc20ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Vault to spend USDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [VAULT_ADDRESS, amountInWei],\n      chainId\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit USDC into Vault\n    txHash = await writeContractAsync({\n      address: VAULT_ADDRESS,\n      abi: vaultABI,\n      functionName: \"deposit\",\n      args: [amountInWei, address],\n      chainId\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}\n",
  "underlyingAsset": "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
  "yieldBearingToken": "0x3ac88AfbC38Bb41443457eeB027b60e85B815538",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68bff2d5e8bb7a6698ff82a6"
  },
  "asset": {
    "$oid": "68b14b6bf55db3d0dfa7df5e"
  },
  "protocol": {
    "$oid": "68bff270e8bb7a6698ff82a5"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const CRUSDC_ADDRESS = \"0x44fbebd2f576670a6c33f6fc0b00aa8c5753b322\";\n\n  const crTokenABI = [\n    {\n      name: \"supplyRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    },\n    {\n      name: \"borrowRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    }\n  ];\n\n  const cr = new ethers.Contract(CRUSDC_ADDRESS, crTokenABI, provider);\n\n  try {\n    const [supplyRatePerBlock, borrowRatePerBlock] = await Promise.all([\n      cr.supplyRatePerBlock(),\n      cr.borrowRatePerBlock()\n    ]);\n    console.log('console',supplyRatePerBlock, borrowRatePerBlock);\n    // Ethereum: ~2102400 blocks/year (15s per block)\n    const blocksPerYear = 2102400;\n\n    function toAPR(ratePerBlock) {\n      return parseFloat(ethers.formatUnits(ratePerBlock, 18)) * blocksPerYear;\n    }\n\n    function toAPY(apr) {\n      return (Math.pow(1 + apr / blocksPerYear, blocksPerYear) - 1) * 100;\n    }\n\n    const supplyAPR = toAPR(supplyRatePerBlock);\n    const borrowAPR = toAPR(borrowRatePerBlock);\n\n    const supplyAPY = toAPY(supplyAPR).toFixed(2);\n    const borrowAPY = toAPY(borrowAPR).toFixed(2);\n\n    console.log(`Cream crUSDC Supply APY: ${supplyAPY}%`);\n    console.log(`Cream crUSDC Borrow APY: ${borrowAPY}%`);\n\n    return { apy: supplyAPY, borrowApy: borrowAPY, rewardApy: null };\n  } catch (err) {\n    console.error(\"Error fetching Cream APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0x44fbebd2f576670a6c33f6fc0b00aa8c5753b322\"; // crUSDC\n\n  const crTokenABI = [\n    {\n      name: \"redeemUnderlying\",\n      inputs: [{ type: \"uint256\", name: \"redeemAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw underlying from Cream\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"redeemUnderlying\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0x44fbebd2f576670a6c33f6fc0b00aa8c5753b322\"; // crUSDC\n  const USDC_ADDRESS = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"; // USDC\n\n  const erc20ABI = [\n    {\n      name: \"approve\",\n      inputs: [\n        { type: \"address\", name: \"spender\" },\n        { type: \"uint256\", name: \"amount\" }\n      ],\n      outputs: [{ type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const crTokenABI = [\n    {\n      name: \"mint\",\n      inputs: [{ type: \"uint256\", name: \"mintAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // 1. Approve USDC -> crUSDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [CRUSDC_ADDRESS, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // 2. Mint crUSDC\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"mint\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  "yieldBearingToken": "0x44fbebd2f576670a6c33f6fc0b00aa8c5753b322",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68bff986ef09c27d07828754"
  },
  "asset": {
    "$oid": "68b14b85f55db3d0dfa7df62"
  },
  "protocol": {
    "$oid": "68bff270e8bb7a6698ff82a5"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const CRUSDC_ADDRESS = \"0x797AAB1ce7c01eB727ab980762bA88e7133d2157\";\n\n  const crTokenABI = [\n    {\n      name: \"supplyRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    },\n    {\n      name: \"borrowRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    }\n  ];\n\n  const cr = new ethers.Contract(CRUSDC_ADDRESS, crTokenABI, provider);\n\n  try {\n    const [supplyRatePerBlock, borrowRatePerBlock] = await Promise.all([\n      cr.supplyRatePerBlock(),\n      cr.borrowRatePerBlock()\n    ]);\n    console.log('console',supplyRatePerBlock, borrowRatePerBlock);\n    // Ethereum: ~2102400 blocks/year (15s per block)\n    const blocksPerYear = 2102400;\n\n    function toAPR(ratePerBlock) {\n      return parseFloat(ethers.formatUnits(ratePerBlock, 18)) * blocksPerYear;\n    }\n\n    function toAPY(apr) {\n      return (Math.pow(1 + apr / blocksPerYear, blocksPerYear) - 1) * 100;\n    }\n\n    const supplyAPR = toAPR(supplyRatePerBlock);\n    const borrowAPR = toAPR(borrowRatePerBlock);\n\n    const supplyAPY = toAPY(supplyAPR).toFixed(2);\n    const borrowAPY = toAPY(borrowAPR).toFixed(2);\n\n    console.log(`Cream crUSDC Supply APY: ${supplyAPY}%`);\n    console.log(`Cream crUSDC Borrow APY: ${borrowAPY}%`);\n\n    return { apy: supplyAPY, borrowApy: borrowAPY, rewardApy: null };\n  } catch (err) {\n    console.error(\"Error fetching Cream APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0x797AAB1ce7c01eB727ab980762bA88e7133d2157\"; // crUSDC\n\n  const crTokenABI = [\n    {\n      name: \"redeemUnderlying\",\n      inputs: [{ type: \"uint256\", name: \"redeemAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw underlying from Cream\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"redeemUnderlying\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0x797AAB1ce7c01eB727ab980762bA88e7133d2157\"; \n  const USDC_ADDRESS = \"0xdac17f958d2ee523a2206206994597c13d831ec7\"; \n\n  const erc20ABI = [\n    {\n      name: \"approve\",\n      inputs: [\n        { type: \"address\", name: \"spender\" },\n        { type: \"uint256\", name: \"amount\" }\n      ],\n      outputs: [{ type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const crTokenABI = [\n    {\n      name: \"mint\",\n      inputs: [{ type: \"uint256\", name: \"mintAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // 1. Approve USDC -> crUSDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [CRUSDC_ADDRESS, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // 2. Mint crUSDC\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"mint\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xdac17f958d2ee523a2206206994597c13d831ec7",
  "yieldBearingToken": "0x797AAB1ce7c01eB727ab980762bA88e7133d2157",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68bffb3bef09c27d07828756"
  },
  "asset": {
    "$oid": "68b14c85f55db3d0dfa7df6f"
  },
  "protocol": {
    "$oid": "68bff270e8bb7a6698ff82a5"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const CRUSDC_ADDRESS = \"0xD06527D5e56A3495252A528C4987003b712860eE\";\n\n  const crTokenABI = [\n    {\n      name: \"supplyRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    },\n    {\n      name: \"borrowRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    }\n  ];\n\n  const cr = new ethers.Contract(CRUSDC_ADDRESS, crTokenABI, provider);\n\n  try {\n    const [supplyRatePerBlock, borrowRatePerBlock] = await Promise.all([\n      cr.supplyRatePerBlock(),\n      cr.borrowRatePerBlock()\n    ]);\n    console.log('console',supplyRatePerBlock, borrowRatePerBlock);\n    // Ethereum: ~2102400 blocks/year (15s per block)\n    const blocksPerYear = 2102400;\n\n    function toAPR(ratePerBlock) {\n      return parseFloat(ethers.formatUnits(ratePerBlock, 18)) * blocksPerYear;\n    }\n\n    function toAPY(apr) {\n      return (Math.pow(1 + apr / blocksPerYear, blocksPerYear) - 1) * 100;\n    }\n\n    const supplyAPR = toAPR(supplyRatePerBlock);\n    const borrowAPR = toAPR(borrowRatePerBlock);\n\n    const supplyAPY = toAPY(supplyAPR).toFixed(2);\n    const borrowAPY = toAPY(borrowAPR).toFixed(2);\n\n    console.log(`Cream crUSDC Supply APY: ${supplyAPY}%`);\n    console.log(`Cream crUSDC Borrow APY: ${borrowAPY}%`);\n\n    return { apy: supplyAPY, borrowApy: borrowAPY, rewardApy: null };\n  } catch (err) {\n    console.error(\"Error fetching Cream APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0xD06527D5e56A3495252A528C4987003b712860eE\"; // crUSDC\n\n  const crTokenABI = [\n    {\n      name: \"redeemUnderlying\",\n      inputs: [{ type: \"uint256\", name: \"redeemAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw underlying from Cream\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"redeemUnderlying\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0xD06527D5e56A3495252A528C4987003b712860eE\"; \n  const USDC_ADDRESS = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"; \n\n  const erc20ABI = [\n    {\n      name: \"approve\",\n      inputs: [\n        { type: \"address\", name: \"spender\" },\n        { type: \"uint256\", name: \"amount\" }\n      ],\n      outputs: [{ type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const crTokenABI = [\n    {\n      name: \"mint\",\n      inputs: [{ type: \"uint256\", name: \"mintAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // 1. Approve USDC -> crUSDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [CRUSDC_ADDRESS, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // 2. Mint crUSDC\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"mint\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "yieldBearingToken": "0xD06527D5e56A3495252A528C4987003b712860eE",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c003b3af43fcc33705d768"
  },
  "asset": {
    "$oid": "68b14c95f55db3d0dfa7df70"
  },
  "protocol": {
    "$oid": "68bff270e8bb7a6698ff82a5"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const CRUSDC_ADDRESS = \"0x92B767185fB3B04F881e3aC8e5B0662a027A1D9f\";\n\n  const crTokenABI = [\n    {\n      name: \"supplyRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    },\n    {\n      name: \"borrowRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    }\n  ];\n\n  const cr = new ethers.Contract(CRUSDC_ADDRESS, crTokenABI, provider);\n\n  try {\n    const [supplyRatePerBlock, borrowRatePerBlock] = await Promise.all([\n      cr.supplyRatePerBlock(),\n      cr.borrowRatePerBlock()\n    ]);\n    console.log('console',supplyRatePerBlock, borrowRatePerBlock);\n    // Ethereum: ~2102400 blocks/year (15s per block)\n    const blocksPerYear = 2102400;\n\n    function toAPR(ratePerBlock) {\n      return parseFloat(ethers.formatUnits(ratePerBlock, 18)) * blocksPerYear;\n    }\n\n    function toAPY(apr) {\n      return (Math.pow(1 + apr / blocksPerYear, blocksPerYear) - 1) * 100;\n    }\n\n    const supplyAPR = toAPR(supplyRatePerBlock);\n    const borrowAPR = toAPR(borrowRatePerBlock);\n\n    const supplyAPY = toAPY(supplyAPR).toFixed(2);\n    const borrowAPY = toAPY(borrowAPR).toFixed(2);\n\n    console.log(`Cream crUSDC Supply APY: ${supplyAPY}%`);\n    console.log(`Cream crUSDC Borrow APY: ${borrowAPY}%`);\n\n    return { apy: supplyAPY, borrowApy: borrowAPY, rewardApy: null };\n  } catch (err) {\n    console.error(\"Error fetching Cream APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0x92B767185fB3B04F881e3aC8e5B0662a027A1D9f\"; // crUSDC\n\n  const crTokenABI = [\n    {\n      name: \"redeemUnderlying\",\n      inputs: [{ type: \"uint256\", name: \"redeemAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw underlying from Cream\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"redeemUnderlying\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0x92B767185fB3B04F881e3aC8e5B0662a027A1D9f\"; \n  const USDC_ADDRESS = \"0x6b175474e89094c44da98b954eedeac495271d0f\"; \n\n  const erc20ABI = [\n    {\n      name: \"approve\",\n      inputs: [\n        { type: \"address\", name: \"spender\" },\n        { type: \"uint256\", name: \"amount\" }\n      ],\n      outputs: [{ type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const crTokenABI = [\n    {\n      name: \"mint\",\n      inputs: [{ type: \"uint256\", name: \"mintAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // 1. Approve USDC -> crUSDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [CRUSDC_ADDRESS, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // 2. Mint crUSDC\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"mint\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x6b175474e89094c44da98b954eedeac495271d0f",
  "yieldBearingToken": "0x92B767185fB3B04F881e3aC8e5B0662a027A1D9f",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c00587af43fcc33705d76a"
  },
  "asset": {
    "$oid": "68b14ac3f55db3d0dfa7df53"
  },
  "protocol": {
    "$oid": "68bff270e8bb7a6698ff82a5"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://bsc-rpc.publicnode.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const CRUSDC_ADDRESS = \"0xEF6d459FE81C3Ed53d292c936b2df5a8084975De\";\n\n  const crTokenABI = [\n    {\n      name: \"supplyRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    },\n    {\n      name: \"borrowRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    }\n  ];\n\n  const cr = new ethers.Contract(CRUSDC_ADDRESS, crTokenABI, provider);\n\n  try {\n    const [supplyRatePerBlock, borrowRatePerBlock] = await Promise.all([\n      cr.supplyRatePerBlock(),\n      cr.borrowRatePerBlock()\n    ]);\n    console.log('console',supplyRatePerBlock, borrowRatePerBlock);\n    // Ethereum: ~2102400 blocks/year (15s per block)\n    const blocksPerYear = 2102400;\n\n    function toAPR(ratePerBlock) {\n      return parseFloat(ethers.formatUnits(ratePerBlock, 18)) * blocksPerYear;\n    }\n\n    function toAPY(apr) {\n      return (Math.pow(1 + apr / blocksPerYear, blocksPerYear) - 1) * 100;\n    }\n\n    const supplyAPR = toAPR(supplyRatePerBlock);\n    const borrowAPR = toAPR(borrowRatePerBlock);\n\n    const supplyAPY = toAPY(supplyAPR).toFixed(2);\n    const borrowAPY = toAPY(borrowAPR).toFixed(2);\n\n    console.log(`Cream crUSDC Supply APY: ${supplyAPY}%`);\n    console.log(`Cream crUSDC Borrow APY: ${borrowAPY}%`);\n\n    return { apy: supplyAPY, borrowApy: borrowAPY, rewardApy: null };\n  } catch (err) {\n    console.error(\"Error fetching Cream APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0xEF6d459FE81C3Ed53d292c936b2df5a8084975De\"; // crUSDC\n\n  const crTokenABI = [\n    {\n      name: \"redeemUnderlying\",\n      inputs: [{ type: \"uint256\", name: \"redeemAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw underlying from Cream\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"redeemUnderlying\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0xEF6d459FE81C3Ed53d292c936b2df5a8084975De\"; \n  const USDC_ADDRESS = \"0x55d398326f99059ff775485246999027b3197955\"; \n\n  const erc20ABI = [\n    {\n      name: \"approve\",\n      inputs: [\n        { type: \"address\", name: \"spender\" },\n        { type: \"uint256\", name: \"amount\" }\n      ],\n      outputs: [{ type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const crTokenABI = [\n    {\n      name: \"mint\",\n      inputs: [{ type: \"uint256\", name: \"mintAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // 1. Approve USDC -> crUSDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [CRUSDC_ADDRESS, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // 2. Mint crUSDC\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"mint\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x55d398326f99059ff775485246999027b3197955",
  "yieldBearingToken": "0xEF6d459FE81C3Ed53d292c936b2df5a8084975De",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c00685af43fcc33705d76c"
  },
  "asset": {
    "$oid": "68af071df48122df91aa93b1"
  },
  "protocol": {
    "$oid": "68bff270e8bb7a6698ff82a5"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://bsc-rpc.publicnode.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const CRUSDC_ADDRESS = \"0xD83C88DB3A6cA4a32FFf1603b0f7DDce01F5f727\";\n\n  const crTokenABI = [\n    {\n      name: \"supplyRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    },\n    {\n      name: \"borrowRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    }\n  ];\n\n  const cr = new ethers.Contract(CRUSDC_ADDRESS, crTokenABI, provider);\n\n  try {\n    const [supplyRatePerBlock, borrowRatePerBlock] = await Promise.all([\n      cr.supplyRatePerBlock(),\n      cr.borrowRatePerBlock()\n    ]);\n    console.log('console',supplyRatePerBlock, borrowRatePerBlock);\n    // Ethereum: ~2102400 blocks/year (15s per block)\n    const blocksPerYear = 2102400;\n\n    function toAPR(ratePerBlock) {\n      return parseFloat(ethers.formatUnits(ratePerBlock, 18)) * blocksPerYear;\n    }\n\n    function toAPY(apr) {\n      return (Math.pow(1 + apr / blocksPerYear, blocksPerYear) - 1) * 100;\n    }\n\n    const supplyAPR = toAPR(supplyRatePerBlock);\n    const borrowAPR = toAPR(borrowRatePerBlock);\n\n    const supplyAPY = toAPY(supplyAPR).toFixed(2);\n    const borrowAPY = toAPY(borrowAPR).toFixed(2);\n\n    console.log(`Cream crUSDC Supply APY: ${supplyAPY}%`);\n    console.log(`Cream crUSDC Borrow APY: ${borrowAPY}%`);\n\n    return { apy: supplyAPY, borrowApy: borrowAPY, rewardApy: null };\n  } catch (err) {\n    console.error(\"Error fetching Cream APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0xD83C88DB3A6cA4a32FFf1603b0f7DDce01F5f727\"; // crUSDC\n\n  const crTokenABI = [\n    {\n      name: \"redeemUnderlying\",\n      inputs: [{ type: \"uint256\", name: \"redeemAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw underlying from Cream\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"redeemUnderlying\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0xD83C88DB3A6cA4a32FFf1603b0f7DDce01F5f727\"; \n  const USDC_ADDRESS = \"0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d\"; \n\n  const erc20ABI = [\n    {\n      name: \"approve\",\n      inputs: [\n        { type: \"address\", name: \"spender\" },\n        { type: \"uint256\", name: \"amount\" }\n      ],\n      outputs: [{ type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const crTokenABI = [\n    {\n      name: \"mint\",\n      inputs: [{ type: \"uint256\", name: \"mintAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // 1. Approve USDC -> crUSDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [CRUSDC_ADDRESS, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // 2. Mint crUSDC\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"mint\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
  "yieldBearingToken": "0xD83C88DB3A6cA4a32FFf1603b0f7DDce01F5f727",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c00721af43fcc33705d76e"
  },
  "asset": {
    "$oid": "68b148e7f55db3d0dfa7df3a"
  },
  "protocol": {
    "$oid": "68bff270e8bb7a6698ff82a5"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://bsc-rpc.publicnode.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const CRUSDC_ADDRESS = \"0xD83C88DB3A6cA4a32FFf1603b0f7DDce01F5f727\";\n\n  const crTokenABI = [\n    {\n      name: \"supplyRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    },\n    {\n      name: \"borrowRatePerBlock\",\n      inputs: [],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\"\n    }\n  ];\n\n  const cr = new ethers.Contract(CRUSDC_ADDRESS, crTokenABI, provider);\n\n  try {\n    const [supplyRatePerBlock, borrowRatePerBlock] = await Promise.all([\n      cr.supplyRatePerBlock(),\n      cr.borrowRatePerBlock()\n    ]);\n    console.log('console',supplyRatePerBlock, borrowRatePerBlock);\n    // Ethereum: ~2102400 blocks/year (15s per block)\n    const blocksPerYear = 2102400;\n\n    function toAPR(ratePerBlock) {\n      return parseFloat(ethers.formatUnits(ratePerBlock, 18)) * blocksPerYear;\n    }\n\n    function toAPY(apr) {\n      return (Math.pow(1 + apr / blocksPerYear, blocksPerYear) - 1) * 100;\n    }\n\n    const supplyAPR = toAPR(supplyRatePerBlock);\n    const borrowAPR = toAPR(borrowRatePerBlock);\n\n    const supplyAPY = toAPY(supplyAPR).toFixed(2);\n    const borrowAPY = toAPY(borrowAPR).toFixed(2);\n\n    console.log(`Cream crUSDC Supply APY: ${supplyAPY}%`);\n    console.log(`Cream crUSDC Borrow APY: ${borrowAPY}%`);\n\n    return { apy: supplyAPY, borrowApy: borrowAPY, rewardApy: null };\n  } catch (err) {\n    console.error(\"Error fetching Cream APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0x9095e8d707E40982aFFce41C61c10895157A1B22\"; // crUSDC\n\n  const crTokenABI = [\n    {\n      name: \"redeemUnderlying\",\n      inputs: [{ type: \"uint256\", name: \"redeemAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    // Withdraw underlying from Cream\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"redeemUnderlying\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const CRUSDC_ADDRESS = \"0x9095e8d707E40982aFFce41C61c10895157A1B22\"; \n  const USDC_ADDRESS = \"0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3\"; \n\n  const erc20ABI = [\n    {\n      name: \"approve\",\n      inputs: [\n        { type: \"address\", name: \"spender\" },\n        { type: \"uint256\", name: \"amount\" }\n      ],\n      outputs: [{ type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  const crTokenABI = [\n    {\n      name: \"mint\",\n      inputs: [{ type: \"uint256\", name: \"mintAmount\" }],\n      outputs: [{ type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\"\n    }\n  ];\n\n  try {\n    let txHash = \"\";\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // 1. Approve USDC -> crUSDC\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20ABI,\n      functionName: \"approve\",\n      args: [CRUSDC_ADDRESS, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // 2. Mint crUSDC\n    txHash = await writeContractAsync({\n      address: CRUSDC_ADDRESS,\n      abi: crTokenABI,\n      functionName: \"mint\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3",
  "yieldBearingToken": "0x9095e8d707E40982aFFce41C61c10895157A1B22",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c264edeaecfa1701077e8a"
  },
  "asset": {
    "$oid": "68b14b46f55db3d0dfa7df5d"
  },
  "protocol": {
    "$oid": "68c26285eaecfa1701077e89"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\"; // Replace with Ethena-supported RPC\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const STAKING_CONTRACT = \"0x9d39a5de30e57443bff2a8307a4256c8797a3497\"; // Ethena staking contract\n  const STAKING_ABI = [\n    \"function convertToAssets(uint256 shares) view returns (uint256)\",\n  ];\n\n  const staking = new ethers.Contract(STAKING_CONTRACT, STAKING_ABI, provider);\n\n  const ONE_SUSDE = ethers.parseUnits(\"1\", 18);\n\n  // get current exchange rate\n  const rateNow = await staking.convertToAssets(ONE_SUSDE);\n\n  // (for demo we fake a past rate; in practice fetch from subgraph or log history)\n  const ratePast = Number(rateNow) * 0.9999;\n\n  const secondsPerYear = 60 * 60 * 24 * 365;\n  const secondsElapsed = 86400; // 1 day\n\n  const apr =\n    (Number(rateNow) / Number(ratePast) - 1) *\n    (secondsPerYear / secondsElapsed);\n  const apy = (Math.pow(1 + apr / 365, 365) - 1) * 100;\n\n  console.log(`Ethena Staking APY: ${apy.toFixed(2)}%`);\n  return { apy };\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const MINT_CONTRACT = \"0xe3490297a08d6fC8Da46Edb7B6142E4F461b62D3\";\n  const COLLATERAL_TOKEN = \"0x4c9EDD5852cd905f086C759E8383e09bff1E68B3\"; // e.g., stETH\n\n  const MINT_ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"collateral\", type: \"address\" },\n        { internalType: \"uint256\", name: \"usdeAmount\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"minCollateralOut\", type: \"uint256\" },\n      ],\n      name: \"redeem\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0 amount\");\n\n    const withdrawTx = await writeContractAsync({\n      address: MINT_CONTRACT,\n      abi: MINT_ABI,\n      functionName: \"redeem\",\n      args: [COLLATERAL_TOKEN, amountInWei, 0], // minOut can be set\n      chainId,\n    });\n\n    return { success: true, txHash: withdrawTx };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const MINT_CONTRACT = \"0xe3490297a08d6fC8Da46Edb7B6142E4F461b62D3\";\n  const COLLATERAL_TOKEN = \"0x4c9EDD5852cd905f086C759E8383e09bff1E68B3\"; // e.g., stETH\n\n  const MINT_ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"collateral\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"minUsdeOut\", type: \"uint256\" },\n      ],\n      name: \"mint\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  const ERC20_ABI = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n      ],\n      name: \"approve\",\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve collateral for mint contract\n    const approveTx = await writeContractAsync({\n      address: COLLATERAL_TOKEN,\n      abi: ERC20_ABI,\n      functionName: \"approve\",\n      args: [MINT_CONTRACT, amountInWei],\n      chainId,\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Mint USDe\n    const mintTx = await writeContractAsync({\n      address: MINT_CONTRACT,\n      abi: MINT_ABI,\n      functionName: \"mint\",\n      args: [COLLATERAL_TOKEN, amountInWei, 0], // set slippage minOut if needed\n      chainId,\n    });\n\n    return { success: true, txHash: mintTx };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit (mint) failed\" };\n  }\n}",
  "underlyingAsset": "",
  "yieldBearingToken": "0xe3490297a08d6fC8Da46Edb7B6142E4F461b62D3",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c268a2eaecfa1701077e8d"
  },
  "asset": {
    "$oid": "68b14b6bf55db3d0dfa7df5e"
  },
  "protocol": {
    "$oid": "68c26839eaecfa1701077e8c"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const KINZA_DATA_PROVIDER = \"0xE44990a8a732605Eddc0870597d2Cf4A2637F038\";\n  const asset = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\"; // USDC\n\n  const dataProviderAbi = [\n    \"function getReserveData(address asset) view returns (uint256 unbacked, uint256 accruedToTreasuryScaled, uint256 totalAToken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\",\n  ];\n\n  const dataProvider = new ethers.Contract(\n    KINZA_DATA_PROVIDER,\n    dataProviderAbi,\n    provider\n  );\n\n  try {\n    const reserve = await dataProvider.getReserveData(asset);\n\n    // Rates in ray (1e27), per second\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rateRay) {\n      const rate = Number(rateRay) / RAY;\n      return (\n        (Math.pow(1 + rate / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100\n      );\n    }\n\n    const supplyAPY = toAPY(reserve.liquidityRate).toFixed(2);\n    const variableBorrowAPY = toAPY(reserve.variableBorrowRate).toFixed(2);\n    const stableBorrowAPY = toAPY(reserve.stableBorrowRate).toFixed(2);\n\n    console.log(`Kinza USDC Supply APY: ${supplyAPY}%`);\n    console.log(`Kinza USDC Variable Borrow APY: ${variableBorrowAPY}%`);\n    console.log(`Kinza USDC Stable Borrow APY: ${stableBorrowAPY}%`);\n\n    return {\n      apy: supplyAPY,\n      borrowApy: variableBorrowAPY,\n      rewardApy: stableBorrowAPY,\n    };\n  } catch (err) {\n    console.error(\"Error fetching Kinza APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});\n",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xeA14474946C59Dee1F103aD517132B3F19Cef1bE\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" },\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"withdraw\",\n      args: [address, amountInWei, user],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xeA14474946C59Dee1F103aD517132B3F19Cef1bE\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" },\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  const erc20Abi = [\n    {\n      name: \"approve\",\n      type: \"function\",\n      stateMutability: \"nonpayable\",\n      inputs: [\n        { name: \"spender\", type: \"address\" },\n        { name: \"amount\", type: \"uint256\" },\n      ],\n      outputs: [{ name: \"\", type: \"bool\" }],\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve\n    const approveTx = await writeContractAsync({\n      address: address,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [KINZA_POOL, amountInWei],\n      chainId,\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"supply\",\n      args: [asset, amountInWei, user, 0],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  "yieldBearingToken": "0xeA14474946C59Dee1F103aD517132B3F19Cef1bE",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c26e7beaecfa1701077e8f"
  },
  "asset": {
    "$oid": "68b14b85f55db3d0dfa7df62"
  },
  "protocol": {
    "$oid": "68c26839eaecfa1701077e8c"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const KINZA_DATA_PROVIDER = \"0xE44990a8a732605Eddc0870597d2Cf4A2637F038\";\n  const asset = \"0xdac17f958d2ee523a2206206994597c13d831ec7\"; // USDC\n\n  const dataProviderAbi = [\n    \"function getReserveData(address asset) view returns (uint256 unbacked, uint256 accruedToTreasuryScaled, uint256 totalAToken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\",\n  ];\n\n  const dataProvider = new ethers.Contract(\n    KINZA_DATA_PROVIDER,\n    dataProviderAbi,\n    provider\n  );\n\n  try {\n    const reserve = await dataProvider.getReserveData(asset);\n\n    // Rates in ray (1e27), per second\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rateRay) {\n      const rate = Number(rateRay) / RAY;\n      return (\n        (Math.pow(1 + rate / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100\n      );\n    }\n\n    const supplyAPY = toAPY(reserve.liquidityRate).toFixed(2);\n    const variableBorrowAPY = toAPY(reserve.variableBorrowRate).toFixed(2);\n    const stableBorrowAPY = toAPY(reserve.stableBorrowRate).toFixed(2);\n\n    return {\n      apy: supplyAPY,\n      borrowApy: variableBorrowAPY,\n      rewardApy: stableBorrowAPY,\n    };\n  } catch (err) {\n    console.error(\"Error fetching Kinza APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xeA14474946C59Dee1F103aD517132B3F19Cef1bE\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" },\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"withdraw\",\n      args: [address, amountInWei, user],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xeA14474946C59Dee1F103aD517132B3F19Cef1bE\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" },\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  const erc20Abi = [\n    {\n      name: \"approve\",\n      type: \"function\",\n      stateMutability: \"nonpayable\",\n      inputs: [\n        { name: \"spender\", type: \"address\" },\n        { name: \"amount\", type: \"uint256\" },\n      ],\n      outputs: [{ name: \"\", type: \"bool\" }],\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve\n    const approveTx = await writeContractAsync({\n      address: address,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [KINZA_POOL, amountInWei],\n      chainId,\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"supply\",\n      args: [asset, amountInWei, user, 0],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xdac17f958d2ee523a2206206994597c13d831ec7",
  "yieldBearingToken": "0xeA14474946C59Dee1F103aD517132B3F19Cef1bE",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c26f7eeaecfa1701077e91"
  },
  "asset": {
    "$oid": "68b14c85f55db3d0dfa7df6f"
  },
  "protocol": {
    "$oid": "68c26839eaecfa1701077e8c"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const KINZA_DATA_PROVIDER = \"0xE44990a8a732605Eddc0870597d2Cf4A2637F038\";\n  const asset = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"; \n\n  const dataProviderAbi = [\n    \"function getReserveData(address asset) view returns (uint256 unbacked, uint256 accruedToTreasuryScaled, uint256 totalAToken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\",\n  ];\n\n  const dataProvider = new ethers.Contract(\n    KINZA_DATA_PROVIDER,\n    dataProviderAbi,\n    provider\n  );\n\n  try {\n    const reserve = await dataProvider.getReserveData(asset);\n\n    // Rates in ray (1e27), per second\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rateRay) {\n      const rate = Number(rateRay) / RAY;\n      return (\n        (Math.pow(1 + rate / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100\n      );\n    }\n\n    const supplyAPY = toAPY(reserve.liquidityRate).toFixed(2);\n    const variableBorrowAPY = toAPY(reserve.variableBorrowRate).toFixed(2);\n    const stableBorrowAPY = toAPY(reserve.stableBorrowRate).toFixed(2);\n\n    return {\n      apy: supplyAPY,\n      borrowApy: variableBorrowAPY,\n      rewardApy: stableBorrowAPY,\n    };\n  } catch (err) {\n    console.error(\"Error fetching Kinza APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xeA14474946C59Dee1F103aD517132B3F19Cef1bE\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" },\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"withdraw\",\n      args: [address, amountInWei, user],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xeA14474946C59Dee1F103aD517132B3F19Cef1bE\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" },\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  const erc20Abi = [\n    {\n      name: \"approve\",\n      type: \"function\",\n      stateMutability: \"nonpayable\",\n      inputs: [\n        { name: \"spender\", type: \"address\" },\n        { name: \"amount\", type: \"uint256\" },\n      ],\n      outputs: [{ name: \"\", type: \"bool\" }],\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve\n    const approveTx = await writeContractAsync({\n      address: address,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [KINZA_POOL, amountInWei],\n      chainId,\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"supply\",\n      args: [asset, amountInWei, user, 0],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "yieldBearingToken": "0xeA14474946C59Dee1F103aD517132B3F19Cef1bE",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c26fcfeaecfa1701077e93"
  },
  "asset": {
    "$oid": "68b14b46f55db3d0dfa7df5d"
  },
  "protocol": {
    "$oid": "68c26839eaecfa1701077e8c"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const KINZA_DATA_PROVIDER = \"0xE44990a8a732605Eddc0870597d2Cf4A2637F038\";\n  const asset = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"; \n\n  const dataProviderAbi = [\n    \"function getReserveData(address asset) view returns (uint256 unbacked, uint256 accruedToTreasuryScaled, uint256 totalAToken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\",\n  ];\n\n  const dataProvider = new ethers.Contract(\n    KINZA_DATA_PROVIDER,\n    dataProviderAbi,\n    provider\n  );\n\n  try {\n    const reserve = await dataProvider.getReserveData(asset);\n\n    // Rates in ray (1e27), per second\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rateRay) {\n      const rate = Number(rateRay) / RAY;\n      return (\n        (Math.pow(1 + rate / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100\n      );\n    }\n\n    const supplyAPY = toAPY(reserve.liquidityRate).toFixed(2);\n    const variableBorrowAPY = toAPY(reserve.variableBorrowRate).toFixed(2);\n    const stableBorrowAPY = toAPY(reserve.stableBorrowRate).toFixed(2);\n\n    return {\n      apy: supplyAPY,\n      borrowApy: variableBorrowAPY,\n      rewardApy: stableBorrowAPY,\n    };\n  } catch (err) {\n    console.error(\"Error fetching Kinza APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xeA14474946C59Dee1F103aD517132B3F19Cef1bE\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" },\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"withdraw\",\n      args: [address, amountInWei, user],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xeA14474946C59Dee1F103aD517132B3F19Cef1bE\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" },\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  const erc20Abi = [\n    {\n      name: \"approve\",\n      type: \"function\",\n      stateMutability: \"nonpayable\",\n      inputs: [\n        { name: \"spender\", type: \"address\" },\n        { name: \"amount\", type: \"uint256\" },\n      ],\n      outputs: [{ name: \"\", type: \"bool\" }],\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve\n    const approveTx = await writeContractAsync({\n      address: address,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [KINZA_POOL, amountInWei],\n      chainId,\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"supply\",\n      args: [asset, amountInWei, user, 0],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "",
  "yieldBearingToken": "0xeA14474946C59Dee1F103aD517132B3F19Cef1bE",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c27019eaecfa1701077e95"
  },
  "asset": {
    "$oid": "68b14c95f55db3d0dfa7df70"
  },
  "protocol": {
    "$oid": "68c26839eaecfa1701077e8c"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const KINZA_DATA_PROVIDER = \"0xE44990a8a732605Eddc0870597d2Cf4A2637F038\";\n  const asset = \"0x6b175474e89094c44da98b954eedeac495271d0f\"; \n\n  const dataProviderAbi = [\n    \"function getReserveData(address asset) view returns (uint256 unbacked, uint256 accruedToTreasuryScaled, uint256 totalAToken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\",\n  ];\n\n  const dataProvider = new ethers.Contract(\n    KINZA_DATA_PROVIDER,\n    dataProviderAbi,\n    provider\n  );\n\n  try {\n    const reserve = await dataProvider.getReserveData(asset);\n\n    // Rates in ray (1e27), per second\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rateRay) {\n      const rate = Number(rateRay) / RAY;\n      return (\n        (Math.pow(1 + rate / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100\n      );\n    }\n\n    const supplyAPY = toAPY(reserve.liquidityRate).toFixed(2);\n    const variableBorrowAPY = toAPY(reserve.variableBorrowRate).toFixed(2);\n    const stableBorrowAPY = toAPY(reserve.stableBorrowRate).toFixed(2);\n\n    return {\n      apy: supplyAPY,\n      borrowApy: variableBorrowAPY,\n      rewardApy: stableBorrowAPY,\n    };\n  } catch (err) {\n    console.error(\"Error fetching Kinza APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xeA14474946C59Dee1F103aD517132B3F19Cef1bE\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" },\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"withdraw\",\n      args: [address, amountInWei, user],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xeA14474946C59Dee1F103aD517132B3F19Cef1bE\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" },\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  const erc20Abi = [\n    {\n      name: \"approve\",\n      type: \"function\",\n      stateMutability: \"nonpayable\",\n      inputs: [\n        { name: \"spender\", type: \"address\" },\n        { name: \"amount\", type: \"uint256\" },\n      ],\n      outputs: [{ name: \"\", type: \"bool\" }],\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve\n    const approveTx = await writeContractAsync({\n      address: address,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [KINZA_POOL, amountInWei],\n      chainId,\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"supply\",\n      args: [asset, amountInWei, user, 0],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x6b175474e89094c44da98b954eedeac495271d0f",
  "yieldBearingToken": "0xeA14474946C59Dee1F103aD517132B3F19Cef1bE",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c274eaeaecfa1701077e97"
  },
  "asset": {
    "$oid": "68af071df48122df91aa93b1"
  },
  "protocol": {
    "$oid": "68c26839eaecfa1701077e8c"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://bsc-rpc.publicnode.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const KINZA_DATA_PROVIDER = \"0x09Ddc4AE826601b0F9671b9edffDf75e7E6f5D61\";\n  const asset = \"0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d\"; \n\n  const dataProviderAbi = [\n    \"function getReserveData(address asset) view returns (uint256 unbacked, uint256 accruedToTreasuryScaled, uint256 totalAToken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\",\n  ];\n\n  const dataProvider = new ethers.Contract(\n    KINZA_DATA_PROVIDER,\n    dataProviderAbi,\n    provider\n  );\n\n  try {\n    const reserve = await dataProvider.getReserveData(asset);\n\n    // Rates in ray (1e27), per second\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rateRay) {\n      const rate = Number(rateRay) / RAY;\n      return (\n        (Math.pow(1 + rate / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100\n      );\n    }\n\n    const supplyAPY = toAPY(reserve.liquidityRate).toFixed(2);\n    const variableBorrowAPY = toAPY(reserve.variableBorrowRate).toFixed(2);\n    const stableBorrowAPY = toAPY(reserve.stableBorrowRate).toFixed(2);\n\n    return {\n      apy: supplyAPY,\n      borrowApy: variableBorrowAPY,\n      rewardApy: stableBorrowAPY,\n    };\n  } catch (err) {\n    console.error(\"Error fetching Kinza APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xcB0620b181140e57D1C0D8b724cde623cA963c8C\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" },\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"withdraw\",\n      args: [address, amountInWei, user],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xcB0620b181140e57D1C0D8b724cde623cA963c8C\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" },\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  const erc20Abi = [\n    {\n      name: \"approve\",\n      type: \"function\",\n      stateMutability: \"nonpayable\",\n      inputs: [\n        { name: \"spender\", type: \"address\" },\n        { name: \"amount\", type: \"uint256\" },\n      ],\n      outputs: [{ name: \"\", type: \"bool\" }],\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve\n    const approveTx = await writeContractAsync({\n      address: address,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [KINZA_POOL, amountInWei],\n      chainId,\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"supply\",\n      args: [asset, amountInWei, user, 0],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}\n",
  "underlyingAsset": "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
  "yieldBearingToken": "0xcB0620b181140e57D1C0D8b724cde623cA963c8C",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c2759d853d24c8982e6f0a"
  },
  "asset": {
    "$oid": "68b14ac3f55db3d0dfa7df53"
  },
  "protocol": {
    "$oid": "68c26839eaecfa1701077e8c"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://bsc-rpc.publicnode.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const KINZA_DATA_PROVIDER = \"0x09Ddc4AE826601b0F9671b9edffDf75e7E6f5D61\";\n  const asset = \"0x55d398326f99059ff775485246999027b3197955\"; \n\n  const dataProviderAbi = [\n    \"function getReserveData(address asset) view returns (uint256 unbacked, uint256 accruedToTreasuryScaled, uint256 totalAToken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\",\n  ];\n\n  const dataProvider = new ethers.Contract(\n    KINZA_DATA_PROVIDER,\n    dataProviderAbi,\n    provider\n  );\n\n  try {\n    const reserve = await dataProvider.getReserveData(asset);\n\n    // Rates in ray (1e27), per second\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rateRay) {\n      const rate = Number(rateRay) / RAY;\n      return (\n        (Math.pow(1 + rate / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100\n      );\n    }\n\n    const supplyAPY = toAPY(reserve.liquidityRate).toFixed(2);\n    const variableBorrowAPY = toAPY(reserve.variableBorrowRate).toFixed(2);\n    const stableBorrowAPY = toAPY(reserve.stableBorrowRate).toFixed(2);\n\n    return {\n      apy: supplyAPY,\n      borrowApy: variableBorrowAPY,\n      rewardApy: stableBorrowAPY,\n    };\n  } catch (err) {\n    console.error(\"Error fetching Kinza APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xcB0620b181140e57D1C0D8b724cde623cA963c8C\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" },\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"withdraw\",\n      args: [address, amountInWei, user],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xcB0620b181140e57D1C0D8b724cde623cA963c8C\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" },\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  const erc20Abi = [\n    {\n      name: \"approve\",\n      type: \"function\",\n      stateMutability: \"nonpayable\",\n      inputs: [\n        { name: \"spender\", type: \"address\" },\n        { name: \"amount\", type: \"uint256\" },\n      ],\n      outputs: [{ name: \"\", type: \"bool\" }],\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve\n    const approveTx = await writeContractAsync({\n      address: address,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [KINZA_POOL, amountInWei],\n      chainId,\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"supply\",\n      args: [asset, amountInWei, user, 0],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x55d398326f99059ff775485246999027b3197955",
  "yieldBearingToken": "0xcB0620b181140e57D1C0D8b724cde623cA963c8C",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c27614853d24c8982e6f0c"
  },
  "asset": {
    "$oid": "68b148e7f55db3d0dfa7df3a"
  },
  "protocol": {
    "$oid": "68c26839eaecfa1701077e8c"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://bsc-rpc.publicnode.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const KINZA_DATA_PROVIDER = \"0x09Ddc4AE826601b0F9671b9edffDf75e7E6f5D61\";\n  const asset = \"0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3\"; \n\n  const dataProviderAbi = [\n    \"function getReserveData(address asset) view returns (uint256 unbacked, uint256 accruedToTreasuryScaled, uint256 totalAToken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\",\n  ];\n\n  const dataProvider = new ethers.Contract(\n    KINZA_DATA_PROVIDER,\n    dataProviderAbi,\n    provider\n  );\n\n  try {\n    const reserve = await dataProvider.getReserveData(asset);\n\n    // Rates in ray (1e27), per second\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rateRay) {\n      const rate = Number(rateRay) / RAY;\n      return (\n        (Math.pow(1 + rate / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100\n      );\n    }\n\n    const supplyAPY = toAPY(reserve.liquidityRate).toFixed(2);\n    const variableBorrowAPY = toAPY(reserve.variableBorrowRate).toFixed(2);\n    const stableBorrowAPY = toAPY(reserve.stableBorrowRate).toFixed(2);\n\n    return {\n      apy: supplyAPY,\n      borrowApy: variableBorrowAPY,\n      rewardApy: stableBorrowAPY,\n    };\n  } catch (err) {\n    console.error(\"Error fetching Kinza APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xcB0620b181140e57D1C0D8b724cde623cA963c8C\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" },\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"withdraw\",\n      args: [address, amountInWei, user],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xcB0620b181140e57D1C0D8b724cde623cA963c8C\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" },\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  const erc20Abi = [\n    {\n      name: \"approve\",\n      type: \"function\",\n      stateMutability: \"nonpayable\",\n      inputs: [\n        { name: \"spender\", type: \"address\" },\n        { name: \"amount\", type: \"uint256\" },\n      ],\n      outputs: [{ name: \"\", type: \"bool\" }],\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve\n    const approveTx = await writeContractAsync({\n      address: address,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [KINZA_POOL, amountInWei],\n      chainId,\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"supply\",\n      args: [asset, amountInWei, user, 0],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3",
  "yieldBearingToken": "0xcB0620b181140e57D1C0D8b724cde623cA963c8C",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c2766e853d24c8982e6f0e"
  },
  "asset": {
    "$oid": "68b0349ae0d13595b429a253"
  },
  "protocol": {
    "$oid": "68c26839eaecfa1701077e8c"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://bsc-rpc.publicnode.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const KINZA_DATA_PROVIDER = \"0x09Ddc4AE826601b0F9671b9edffDf75e7E6f5D61\";\n  const asset = \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\"; \n\n  const dataProviderAbi = [\n    \"function getReserveData(address asset) view returns (uint256 unbacked, uint256 accruedToTreasuryScaled, uint256 totalAToken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\",\n  ];\n\n  const dataProvider = new ethers.Contract(\n    KINZA_DATA_PROVIDER,\n    dataProviderAbi,\n    provider\n  );\n\n  try {\n    const reserve = await dataProvider.getReserveData(asset);\n\n    // Rates in ray (1e27), per second\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function toAPY(rateRay) {\n      const rate = Number(rateRay) / RAY;\n      return (\n        (Math.pow(1 + rate / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100\n      );\n    }\n\n    const supplyAPY = toAPY(reserve.liquidityRate).toFixed(2);\n    const variableBorrowAPY = toAPY(reserve.variableBorrowRate).toFixed(2);\n    const stableBorrowAPY = toAPY(reserve.stableBorrowRate).toFixed(2);\n\n    return {\n      apy: supplyAPY,\n      borrowApy: variableBorrowAPY,\n      rewardApy: stableBorrowAPY,\n    };\n  } catch (err) {\n    console.error(\"Error fetching Kinza APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xcB0620b181140e57D1C0D8b724cde623cA963c8C\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"to\", type: \"address\" },\n      ],\n      name: \"withdraw\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"withdraw\",\n      args: [address, amountInWei, user],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const KINZA_POOL = \"0xcB0620b181140e57D1C0D8b724cde623cA963c8C\";\n\n  const poolAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"asset\", type: \"address\" },\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"address\", name: \"onBehalfOf\", type: \"address\" },\n        { internalType: \"uint16\", name: \"referralCode\", type: \"uint16\" },\n      ],\n      name: \"supply\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  const erc20Abi = [\n    {\n      name: \"approve\",\n      type: \"function\",\n      stateMutability: \"nonpayable\",\n      inputs: [\n        { name: \"spender\", type: \"address\" },\n        { name: \"amount\", type: \"uint256\" },\n      ],\n      outputs: [{ name: \"\", type: \"bool\" }],\n    },\n  ];\n\n  try {\n    let success = false;\n    let txHash = \"\";\n\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve\n    const approveTx = await writeContractAsync({\n      address: address,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [KINZA_POOL, amountInWei],\n      chainId,\n    });\n\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Deposit\n    txHash = await writeContractAsync({\n      address: KINZA_POOL,\n      abi: poolAbi,\n      functionName: \"supply\",\n      args: [asset, amountInWei, user, 0],\n      chainId,\n    });\n\n    success = true;\n    return { success, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
  "yieldBearingToken": "0xcB0620b181140e57D1C0D8b724cde623cA963c8C",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c2c145416be2831e43f871"
  },
  "asset": {
    "$oid": "68b14b6bf55db3d0dfa7df5e"
  },
  "protocol": {
    "$oid": "68c2bf3c416be2831e43f870"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\"; // Ethereum RPC\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // Pool Data Provider (you gave this)\n  const POOL_DATA_PROVIDER = \"0x47223D4eA966a93b2cC96FFB4D42c22651FADFcf\";\n\n  // Example: USDC on Ethereum\n  const USDC_ADDRESS = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\";\n\n  const poolDataProviderAbi = [\n    \"function getReserveData(address asset) view returns (uint256 unbacked, uint256 accruedToTreasuryScaled, uint256 totalAToken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\"\n  ];\n\n  const dataProvider = new ethers.Contract(\n    POOL_DATA_PROVIDER,\n    poolDataProviderAbi,\n    provider\n  );\n\n  try {\n    const reserve = await dataProvider.getReserveData(USDC_ADDRESS);\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function rateToAPY(rate) {\n      const rateFloat = Number(rate) / RAY;\n      return (\n        (Math.pow(1 + rateFloat / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100\n      );\n    }\n\n    const supplyAPY = rateToAPY(reserve.liquidityRate).toFixed(2);\n    const variableBorrowAPY = rateToAPY(reserve.variableBorrowRate).toFixed(2);\n    const stableBorrowAPY = rateToAPY(reserve.stableBorrowRate).toFixed(2);\n\n    console.log(\n      `USDC Supply APY: ${supplyAPY}% | Variable Borrow APY: ${variableBorrowAPY}% | Stable Borrow APY: ${stableBorrowAPY}%`\n    );\n\n    return {\n      apy: supplyAPY,\n      borrowApy: variableBorrowAPY,\n      rewardApy: stableBorrowAPY,\n    };\n  } catch (err) {\n    console.error(\"Error fetching APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const POOL_ADDRESS = \"0xFF679e5B4178A2f74A56f0e2c0e1FA1C80579385\"; // fetch via PoolAddressesProvider\n  const USDC_ADDRESS = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\";\n\n  const poolAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"asset\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    const txHash = await writeContractAsync({\n      address: POOL_ADDRESS,\n      abi: poolAbi,\n      functionName: \"withdraw\",\n      args: [USDC_ADDRESS, amountInWei, address],\n      chainId,\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const POOL_ADDRESS = \"0xFF679e5B4178A2f74A56f0e2c0e1FA1C80579385\";\n  const USDC_ADDRESS = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\";\n\n  const poolAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"asset\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"onBehalfOf\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint16\",\n        \"name\": \"referralCode\",\n        \"type\": \"uint16\"\n      }\n    ],\n    \"name\": \"supply\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n  const erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Pool to spend USDC\n    await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [POOL_ADDRESS, amountInWei],\n      chainId,\n    });\n\n    // Supply to pool\n    const txHash = await writeContractAsync({\n      address: POOL_ADDRESS,\n      abi: poolAbi,\n      functionName: \"supply\",\n      args: [USDC_ADDRESS, amountInWei, address, 0], // referralCode = 0\n      chainId,\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  "yieldBearingToken": "0xFF679e5B4178A2f74A56f0e2c0e1FA1C80579385",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c2c25c416be2831e43f873"
  },
  "asset": {
    "$oid": "68b14b85f55db3d0dfa7df62"
  },
  "protocol": {
    "$oid": "68c2bf3c416be2831e43f870"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\"; \n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const POOL_DATA_PROVIDER = \"0x47223D4eA966a93b2cC96FFB4D42c22651FADFcf\";\n  const USDC_ADDRESS = \"0xdac17f958d2ee523a2206206994597c13d831ec7\";\n\n  const poolDataProviderAbi = [\n    \"function getReserveData(address asset) view returns (uint256 unbacked, uint256 accruedToTreasuryScaled, uint256 totalAToken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\"\n  ];\n\n  const dataProvider = new ethers.Contract(\n    POOL_DATA_PROVIDER,\n    poolDataProviderAbi,\n    provider\n  );\n\n  try {\n    const reserve = await dataProvider.getReserveData(USDC_ADDRESS);\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function rateToAPY(rate) {\n      const rateFloat = Number(rate) / RAY;\n      return (\n        (Math.pow(1 + rateFloat / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100\n      );\n    }\n\n    const supplyAPY = rateToAPY(reserve.liquidityRate).toFixed(2);\n    const variableBorrowAPY = rateToAPY(reserve.variableBorrowRate).toFixed(2);\n    const stableBorrowAPY = rateToAPY(reserve.stableBorrowRate).toFixed(2);\n\n    console.log(\n      `USDC Supply APY: ${supplyAPY}% | Variable Borrow APY: ${variableBorrowAPY}% | Stable Borrow APY: ${stableBorrowAPY}%`\n    );\n\n    return {\n      apy: supplyAPY,\n      borrowApy: variableBorrowAPY,\n      rewardApy: stableBorrowAPY,\n    };\n  } catch (err) {\n    console.error(\"Error fetching APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const POOL_ADDRESS = \"0xFF679e5B4178A2f74A56f0e2c0e1FA1C80579385\"; // fetch via PoolAddressesProvider\n  const USDC_ADDRESS = \"0xdac17f958d2ee523a2206206994597c13d831ec7\";\n\n  const poolAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"asset\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    const txHash = await writeContractAsync({\n      address: POOL_ADDRESS,\n      abi: poolAbi,\n      functionName: \"withdraw\",\n      args: [USDC_ADDRESS, amountInWei, address],\n      chainId,\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const POOL_ADDRESS = \"0xFF679e5B4178A2f74A56f0e2c0e1FA1C80579385\";\n  const USDC_ADDRESS = \"0xdac17f958d2ee523a2206206994597c13d831ec7\";\n\n  const poolAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"asset\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"onBehalfOf\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint16\",\n        \"name\": \"referralCode\",\n        \"type\": \"uint16\"\n      }\n    ],\n    \"name\": \"supply\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n  const erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Pool to spend USDC\n    await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [POOL_ADDRESS, amountInWei],\n      chainId,\n    });\n\n    // Supply to pool\n    const txHash = await writeContractAsync({\n      address: POOL_ADDRESS,\n      abi: poolAbi,\n      functionName: \"supply\",\n      args: [USDC_ADDRESS, amountInWei, address, 0], // referralCode = 0\n      chainId,\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xdac17f958d2ee523a2206206994597c13d831ec7",
  "yieldBearingToken": "0xFF679e5B4178A2f74A56f0e2c0e1FA1C80579385",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c2c3c7416be2831e43f875"
  },
  "asset": {
    "$oid": "68b14c95f55db3d0dfa7df70"
  },
  "protocol": {
    "$oid": "68c2bf3c416be2831e43f870"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\"; \n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const POOL_DATA_PROVIDER = \"0x47223D4eA966a93b2cC96FFB4D42c22651FADFcf\";\n  const USDC_ADDRESS = \"0x6b175474e89094c44da98b954eedeac495271d0f\";\n\n  const poolDataProviderAbi = [\n    \"function getReserveData(address asset) view returns (uint256 unbacked, uint256 accruedToTreasuryScaled, uint256 totalAToken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\"\n  ];\n\n  const dataProvider = new ethers.Contract(\n    POOL_DATA_PROVIDER,\n    poolDataProviderAbi,\n    provider\n  );\n\n  try {\n    const reserve = await dataProvider.getReserveData(USDC_ADDRESS);\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function rateToAPY(rate) {\n      const rateFloat = Number(rate) / RAY;\n      return (\n        (Math.pow(1 + rateFloat / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100\n      );\n    }\n\n    const supplyAPY = rateToAPY(reserve.liquidityRate).toFixed(2);\n    const variableBorrowAPY = rateToAPY(reserve.variableBorrowRate).toFixed(2);\n    const stableBorrowAPY = rateToAPY(reserve.stableBorrowRate).toFixed(2);\n\n    console.log(\n      `USDC Supply APY: ${supplyAPY}% | Variable Borrow APY: ${variableBorrowAPY}% | Stable Borrow APY: ${stableBorrowAPY}%`\n    );\n\n    return {\n      apy: supplyAPY,\n      borrowApy: variableBorrowAPY,\n      rewardApy: stableBorrowAPY,\n    };\n  } catch (err) {\n    console.error(\"Error fetching APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const POOL_ADDRESS = \"0xFF679e5B4178A2f74A56f0e2c0e1FA1C80579385\"; \n  const USDC_ADDRESS = \"0x6b175474e89094c44da98b954eedeac495271d0f\";\n\n  const poolAbi =[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"asset\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    const txHash = await writeContractAsync({\n      address: POOL_ADDRESS,\n      abi: poolAbi,\n      functionName: \"withdraw\",\n      args: [USDC_ADDRESS, amountInWei, address],\n      chainId,\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const POOL_ADDRESS = \"0xFF679e5B4178A2f74A56f0e2c0e1FA1C80579385\";\n  const USDC_ADDRESS = \"0x6b175474e89094c44da98b954eedeac495271d0f\";\n\n  const poolAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"asset\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"onBehalfOf\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint16\",\n        \"name\": \"referralCode\",\n        \"type\": \"uint16\"\n      }\n    ],\n    \"name\": \"supply\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n  const erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Pool to spend USDC\n    await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [POOL_ADDRESS, amountInWei],\n      chainId,\n    });\n\n    // Supply to pool\n    const txHash = await writeContractAsync({\n      address: POOL_ADDRESS,\n      abi: poolAbi,\n      functionName: \"supply\",\n      args: [USDC_ADDRESS, amountInWei, address, 0],\n      chainId,\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x6b175474e89094c44da98b954eedeac495271d0f",
  "yieldBearingToken": "0xFF679e5B4178A2f74A56f0e2c0e1FA1C80579385",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c2c42e416be2831e43f877"
  },
  "asset": {
    "$oid": "68b14c85f55db3d0dfa7df6f"
  },
  "protocol": {
    "$oid": "68c2bf3c416be2831e43f870"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\"; \n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const POOL_DATA_PROVIDER = \"0x47223D4eA966a93b2cC96FFB4D42c22651FADFcf\";\n  const USDC_ADDRESS = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";\n\n  const poolDataProviderAbi = [\n    \"function getReserveData(address asset) view returns (uint256 unbacked, uint256 accruedToTreasuryScaled, uint256 totalAToken, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\"\n  ];\n\n  const dataProvider = new ethers.Contract(\n    POOL_DATA_PROVIDER,\n    poolDataProviderAbi,\n    provider\n  );\n\n  try {\n    const reserve = await dataProvider.getReserveData(USDC_ADDRESS);\n\n    const RAY = 1e27;\n    const SECONDS_PER_YEAR = 31536000;\n\n    function rateToAPY(rate) {\n      const rateFloat = Number(rate) / RAY;\n      return (\n        (Math.pow(1 + rateFloat / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1) * 100\n      );\n    }\n\n    const supplyAPY = rateToAPY(reserve.liquidityRate).toFixed(2);\n    const variableBorrowAPY = rateToAPY(reserve.variableBorrowRate).toFixed(2);\n    const stableBorrowAPY = rateToAPY(reserve.stableBorrowRate).toFixed(2);\n\n    console.log(\n      `USDC Supply APY: ${supplyAPY}% | Variable Borrow APY: ${variableBorrowAPY}% | Stable Borrow APY: ${stableBorrowAPY}%`\n    );\n\n    return {\n      apy: supplyAPY,\n      borrowApy: variableBorrowAPY,\n      rewardApy: stableBorrowAPY,\n    };\n  } catch (err) {\n    console.error(\"Error fetching APY:\", err.message);\n    return { apy: null, borrowApy: null, rewardApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const POOL_ADDRESS = \"0xFF679e5B4178A2f74A56f0e2c0e1FA1C80579385\"; \n  const USDC_ADDRESS = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";\n\n  const poolAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"asset\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    const txHash = await writeContractAsync({\n      address: POOL_ADDRESS,\n      abi: poolAbi,\n      functionName: \"withdraw\",\n      args: [USDC_ADDRESS, amountInWei, address],\n      chainId,\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const POOL_ADDRESS = \"0xFF679e5B4178A2f74A56f0e2c0e1FA1C80579385\";\n  const USDC_ADDRESS = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";\n\n  const poolAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"asset\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"onBehalfOf\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint16\",\n        \"name\": \"referralCode\",\n        \"type\": \"uint16\"\n      }\n    ],\n    \"name\": \"supply\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n  const erc20Abi =[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Approve Pool to spend USDC\n    await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [POOL_ADDRESS, amountInWei],\n      chainId,\n    });\n\n    // Supply to pool\n    const txHash = await writeContractAsync({\n      address: POOL_ADDRESS,\n      abi: poolAbi,\n      functionName: \"supply\",\n      args: [USDC_ADDRESS, amountInWei, address, 0],\n      chainId,\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "yieldBearingToken": "0xFF679e5B4178A2f74A56f0e2c0e1FA1C80579385",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c3d0148f07c736ffcad23f"
  },
  "asset": {
    "$oid": "68b14cd8f55db3d0dfa7df75"
  },
  "protocol": {
    "$oid": "68c3cfbf8f07c736ffcad23e"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://arb1.arbitrum.io/rpc\"; // Arbitrum\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const DOLOMITE_MARGIN = \"0x6Bd780E7fDf01D77e4d475c821f1e7AE05409072\"; // Dolomite Margin core contract\n  const USDC_ADDRESS = \"0xaf88d065e77c8cC2239327C5EDb3A432268e5831\";\n\n  const dolomiteAbi = [\n    \"function getMarketIdByTokenAddress(address token) view returns (uint256)\",\n    \"function getMarketInterestRate(uint256 marketId) view returns (tuple(uint256 value))\",\n    \"function getEarningsRate() view returns (tuple(uint256 value))\"\n  ];\n\n  const dolomite = new ethers.Contract(DOLOMITE_MARGIN, dolomiteAbi, provider);\n\n  try {\n    // 1. Get USDC market ID\n    const marketId = await dolomite.getMarketIdByTokenAddress(USDC_ADDRESS);\n\n    // 2. Fetch borrow rate (per-second, scaled by 1e18)\n    const rateStruct = await dolomite.getMarketInterestRate(marketId);\n    const borrowRatePerSecond = Number(rateStruct.value) / 1e18;\n\n    // 3. Fetch earnings rate (portion of interest paid to suppliers)\n    const earningsStruct = await dolomite.getEarningsRate();\n    const earningsRate = Number(earningsStruct.value) / 1e18;\n\n    // 4. Convert APR  APY\n    const SECONDS_PER_YEAR = 60 * 60 * 24 * 365;\n\n    function aprToApy(ratePerSecond) {\n      return (\n        (Math.pow(1 + ratePerSecond, SECONDS_PER_YEAR) - 1) * 100\n      ).toFixed(2);\n    }\n\n    const borrowApy = aprToApy(borrowRatePerSecond);\n    const supplyApy = (parseFloat(borrowApy) * earningsRate).toFixed(2);\n\n    console.log(`Dolomite USDC Borrow APY: ${borrowApy}%`);\n    console.log(`Dolomite USDC Supply APY: ${supplyApy}%`);\n\n    return { borrowApy, apy: supplyApy };\n  } catch (err) {\n    console.error(\"Error fetching Dolomite APY:\", err.message);\n    return { borrowApy: null, apy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const ROUTER_ADDRESS = \"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\"; \n  const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fromAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    const txHash = await writeContractAsync({\n      address: ROUTER_ADDRESS,\n      abi: routerAbi,\n      functionName: \"withdraw\",\n      args: [0, 0, /* USDC marketId */ 1, amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const ROUTER_ADDRESS = \"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\"; // replace with real router address\n  const USDC_ADDRESS = \"0xaf88d065e77c8cC2239327C5EDb3A432268e5831\";\n\n  const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"toAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"eventFlag\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"name\": \"depositWei\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  const erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Step 1: Approve router\n    const approveTx = await writeContractAsync({\n      address: USDC_ADDRESS,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [ROUTER_ADDRESS, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Step 2: Deposit\n    const txHash = await writeContractAsync({\n      address: ROUTER_ADDRESS,\n      abi: routerAbi,\n      functionName: \"depositWei\",\n      args: [0, 0, /* USDC marketId */ 1, amountInWei, 0],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
  "yieldBearingToken": "0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c3ec628f07c736ffcad241"
  },
  "asset": {
    "$oid": "68b14ce5f55db3d0dfa7df79"
  },
  "protocol": {
    "$oid": "68c3cfbf8f07c736ffcad23e"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const DOLOMITE_MARGIN = \"0x6Bd780E7fDf01D77e4d475c821f1e7AE05409072\"; // Dolomite core\n  const USDT_ADDRESS = \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\"; // Arbitrum USDT\n\n  const dolomiteAbi = [\n    \"function getMarketIdByTokenAddress(address token) view returns (uint256)\",\n    \"function getMarketInterestRate(uint256 marketId) view returns (tuple(uint256 value))\",\n    \"function getEarningsRate() view returns (tuple(uint256 value))\"\n  ];\n\n  const dolomite = new ethers.Contract(DOLOMITE_MARGIN, dolomiteAbi, provider);\n\n  try {\n    const marketId = await dolomite.getMarketIdByTokenAddress(USDT_ADDRESS);\n\n    const rateStruct = await dolomite.getMarketInterestRate(marketId);\n    const borrowRatePerSecond = Number(rateStruct.value) / 1e18;\n\n    const earningsStruct = await dolomite.getEarningsRate();\n    const earningsRate = Number(earningsStruct.value) / 1e18;\n\n    const SECONDS_PER_YEAR = 60 * 60 * 24 * 365;\n\n    function aprToApy(ratePerSecond) {\n      return (\n        (Math.pow(1 + ratePerSecond, SECONDS_PER_YEAR) - 1) * 100\n      ).toFixed(2);\n    }\n\n    const borrowApy = aprToApy(borrowRatePerSecond);\n    const supplyApy = (parseFloat(borrowApy) * earningsRate).toFixed(2);\n\n    console.log(`Dolomite USDT Borrow APY: ${borrowApy}%`);\n    console.log(`Dolomite USDT Supply APY: ${supplyApy}%`);\n\n    return { borrowApy, apy: supplyApy };\n  } catch (err) {\n    console.error(\"Error fetching Dolomite APY:\", err.message);\n    return { borrowApy: null, apy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const ROUTER_ADDRESS = \"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n  const USDT_ADDRESS = \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\";\n\n  const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fromAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    // Fetch marketId dynamically\n    const dolomite = new ethers.Contract(\n      \"0x6Bd780E7fDf01D77e4d475c821f1e7AE05409072\",\n      [\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"],\n      new ethers.JsonRpcProvider(\"https://arb1.arbitrum.io/rpc\")\n    );\n    const marketId = await dolomite.getMarketIdByTokenAddress(USDT_ADDRESS);\n\n    const txHash = await writeContractAsync({\n      address: ROUTER_ADDRESS,\n      abi: routerAbi,\n      functionName: \"withdraw\",\n      args: [0, 0, marketId, amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}\n",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const ROUTER_ADDRESS = \"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n  const USDT_ADDRESS = \"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\";\n\n  const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"toAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"eventFlag\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"name\": \"depositWei\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  const erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Step 1: Approve router\n    const approveTx = await writeContractAsync({\n      address: USDT_ADDRESS,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [ROUTER_ADDRESS, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Step 2: Get USDT marketId dynamically\n    const dolomite = new ethers.Contract(\n      \"0x6Bd780E7fDf01D77e4d475c821f1e7AE05409072\",\n      [\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"],\n      new ethers.JsonRpcProvider(\"https://arb1.arbitrum.io/rpc\")\n    );\n    const marketId = await dolomite.getMarketIdByTokenAddress(USDT_ADDRESS);\n\n    // Step 3: Deposit\n    const txHash = await writeContractAsync({\n      address: ROUTER_ADDRESS,\n      abi: routerAbi,\n      functionName: \"depositWei\",\n      args: [0, 0, marketId, amountInWei, 0],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
  "yieldBearingToken": "0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c3ed09a15cdf31834b3416"
  },
  "asset": {
    "$oid": "68b14cf4f55db3d0dfa7df7a"
  },
  "protocol": {
    "$oid": "68c3cfbf8f07c736ffcad23e"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const DOLOMITE_MARGIN = \"0x6Bd780E7fDf01D77e4d475c821f1e7AE05409072\"; // Dolomite core\n  const WETH_ADDRESS = \"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\"; // Arbitrum WETH\n\n  const dolomiteAbi = [\n    \"function getMarketIdByTokenAddress(address token) view returns (uint256)\",\n    \"function getMarketInterestRate(uint256 marketId) view returns (tuple(uint256 value))\",\n    \"function getEarningsRate() view returns (tuple(uint256 value))\"\n  ];\n\n  const dolomite = new ethers.Contract(DOLOMITE_MARGIN, dolomiteAbi, provider);\n\n  try {\n    const marketId = await dolomite.getMarketIdByTokenAddress(WETH_ADDRESS);\n\n    const rateStruct = await dolomite.getMarketInterestRate(marketId);\n    const borrowRatePerSecond = Number(rateStruct.value) / 1e18;\n\n    const earningsStruct = await dolomite.getEarningsRate();\n    const earningsRate = Number(earningsStruct.value) / 1e18;\n\n    const SECONDS_PER_YEAR = 60 * 60 * 24 * 365;\n\n    function aprToApy(ratePerSecond) {\n      return ((Math.pow(1 + ratePerSecond, SECONDS_PER_YEAR) - 1) * 100).toFixed(2);\n    }\n\n    const borrowApy = aprToApy(borrowRatePerSecond);\n    const supplyApy = (parseFloat(borrowApy) * earningsRate).toFixed(2);\n\n    console.log(`Dolomite WETH Borrow APY: ${borrowApy}%`);\n    console.log(`Dolomite WETH Supply APY: ${supplyApy}%`);\n\n    return { borrowApy, apy: supplyApy };\n  } catch (err) {\n    console.error(\"Error fetching Dolomite APY:\", err.message);\n    return { borrowApy: null, apy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const ROUTER_ADDRESS = \"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n  const WETH_ADDRESS = \"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\";\n\n  const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fromAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    // Fetch marketId dynamically\n    const dolomite = new ethers.Contract(\n      \"0x6Bd780E7fDf01D77e4d475c821f1e7AE05409072\",\n      [\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"],\n      new ethers.JsonRpcProvider(\"https://arb1.arbitrum.io/rpc\")\n    );\n    const marketId = await dolomite.getMarketIdByTokenAddress(WETH_ADDRESS);\n\n    const txHash = await writeContractAsync({\n      address: ROUTER_ADDRESS,\n      abi: routerAbi,\n      functionName: \"withdraw\",\n      args: [0, 0, marketId, amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const ROUTER_ADDRESS = \"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n  const WETH_ADDRESS = \"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\";\n\n  const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"toAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"eventFlag\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"name\": \"depositWei\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  const erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Step 1: Approve router\n    const approveTx = await writeContractAsync({\n      address: WETH_ADDRESS,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [ROUTER_ADDRESS, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Step 2: Get WETH marketId dynamically\n    const dolomite = new ethers.Contract(\n      \"0x6Bd780E7fDf01D77e4d475c821f1e7AE05409072\",\n      [\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"],\n      new ethers.JsonRpcProvider(\"https://arb1.arbitrum.io/rpc\")\n    );\n    const marketId = await dolomite.getMarketIdByTokenAddress(WETH_ADDRESS);\n\n    // Step 3: Deposit\n    const txHash = await writeContractAsync({\n      address: ROUTER_ADDRESS,\n      abi: routerAbi,\n      functionName: \"depositWei\",\n      args: [0, 0, marketId, amountInWei, 0],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
  "yieldBearingToken": "0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c3ef41d0b63e39e3bd28fe"
  },
  "asset": {
    "$oid": "68b14d05f55db3d0dfa7df7b"
  },
  "protocol": {
    "$oid": "68c3cfbf8f07c736ffcad23e"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://arb1.arbitrum.io/rpc\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const DOLOMITE_MARGIN = \"0x6Bd780E7fDf01D77e4d475c821f1e7AE05409072\"; // Dolomite core\n  const DAI_ADDRESS = \"0xda10009cbd5d07dd0cecc66161fc93d7c9000da1\"; // Arbitrum DAI\n\n  const dolomiteAbi = [\n    \"function getMarketIdByTokenAddress(address token) view returns (uint256)\",\n    \"function getMarketInterestRate(uint256 marketId) view returns (tuple(uint256 value))\",\n    \"function getEarningsRate() view returns (tuple(uint256 value))\"\n  ];\n\n  const dolomite = new ethers.Contract(DOLOMITE_MARGIN, dolomiteAbi, provider);\n\n  try {\n    const marketId = await dolomite.getMarketIdByTokenAddress(DAI_ADDRESS);\n\n    const rateStruct = await dolomite.getMarketInterestRate(marketId);\n    const borrowRatePerSecond = Number(rateStruct.value) / 1e18;\n\n    const earningsStruct = await dolomite.getEarningsRate();\n    const earningsRate = Number(earningsStruct.value) / 1e18;\n\n    const SECONDS_PER_YEAR = 60 * 60 * 24 * 365;\n\n    function aprToApy(ratePerSecond) {\n      return ((Math.pow(1 + ratePerSecond, SECONDS_PER_YEAR) - 1) * 100).toFixed(2);\n    }\n\n    const borrowApy = aprToApy(borrowRatePerSecond);\n    const supplyApy = (parseFloat(borrowApy) * earningsRate).toFixed(2);\n\n    console.log(`Dolomite DAI Borrow APY: ${borrowApy}%`);\n    console.log(`Dolomite DAI Supply APY: ${supplyApy}%`);\n\n    return { borrowApy, apy: supplyApy };\n  } catch (err) {\n    console.error(\"Error fetching Dolomite APY:\", err.message);\n    return { borrowApy: null, apy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId) {\n  const ROUTER_ADDRESS = \"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n  const DAI_ADDRESS = \"0xda10009cbd5d07dd0cecc66161fc93d7c9000da1\";\n\n  const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fromAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    // Fetch marketId dynamically\n    const dolomite = new ethers.Contract(\n      \"0x6Bd780E7fDf01D77e4d475c821f1e7AE05409072\",\n      [\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"],\n      new ethers.JsonRpcProvider(\"https://arb1.arbitrum.io/rpc\")\n    );\n    const marketId = await dolomite.getMarketIdByTokenAddress(DAI_ADDRESS);\n\n    const txHash = await writeContractAsync({\n      address: ROUTER_ADDRESS,\n      abi: routerAbi,\n      functionName: \"withdraw\",\n      args: [0, 0, marketId, amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const ROUTER_ADDRESS = \"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n  const DAI_ADDRESS = \"0xda10009cbd5d07dd0cecc66161fc93d7c9000da1\";\n\n  const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"toAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"eventFlag\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"name\": \"depositWei\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  const erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Step 1: Approve router\n    const approveTx = await writeContractAsync({\n      address: DAI_ADDRESS,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [ROUTER_ADDRESS, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Step 2: Get DAI marketId dynamically\n    const dolomite = new ethers.Contract(\n      \"0x6Bd780E7fDf01D77e4d475c821f1e7AE05409072\",\n      [\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"],\n      new ethers.JsonRpcProvider(\"https://arb1.arbitrum.io/rpc\")\n    );\n    const marketId = await dolomite.getMarketIdByTokenAddress(DAI_ADDRESS);\n\n    // Step 3: Deposit\n    const txHash = await writeContractAsync({\n      address: ROUTER_ADDRESS,\n      abi: routerAbi,\n      functionName: \"depositWei\",\n      args: [0, 0, marketId, amountInWei, 0],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xda10009cbd5d07dd0cecc66161fc93d7c9000da1",
  "yieldBearingToken": "0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c3fe9566eaae5f28322068"
  },
  "asset": {
    "$oid": "68b14b6bf55db3d0dfa7df5e"
  },
  "protocol": {
    "$oid": "68c3cfbf8f07c736ffcad23e"
  },
  "underlyingAsset": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  "yieldBearingToken": "0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf",
  "apy": "(async function(ethers){\n      const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n      const provider = new ethers.JsonRpcProvider(RPC_URL);\n      const DOLOMITE_MARGIN = \"0x003Ca23Fd5F0ca87D01F6eC6CD14A8AE60c2b97D\";\n      const USDC_ADDRESS = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\";\n      const dolomiteAbi = [\n        \"function getMarketIdByTokenAddress(address token) view returns (uint256)\",\n        \"function getMarketInterestRate(uint256 marketId) view returns (tuple(uint256 value))\",\n        \"function getEarningsRate() view returns (tuple(uint256 value))\"\n      ];\n      const dolomite = new ethers.Contract(DOLOMITE_MARGIN, dolomiteAbi, provider);\n      try {\n        const marketId = await dolomite.getMarketIdByTokenAddress(USDC_ADDRESS);\n        const rateStruct = await dolomite.getMarketInterestRate(marketId);\n        const borrowRatePerSecond = Number(rateStruct.value) / 1e18;\n        const earningsStruct = await dolomite.getEarningsRate();\n        const earningsRate = Number(earningsStruct.value) / 1e18;\n        const SECONDS_PER_YEAR = 60 * 60 * 24 * 365;\n        const aprToApy = (rate) => ((Math.pow(1 + rate, SECONDS_PER_YEAR) - 1) * 100).toFixed(2);\n        const borrowApy = aprToApy(borrowRatePerSecond);\n        const supplyApy = (parseFloat(borrowApy) * earningsRate).toFixed(2);\n        return { borrowApy, apy: supplyApy };\n      } catch (err) {\n        return { borrowApy: null, apy: null };\n      }\n    })",
  "deposit": "(async function deposit(amount, address, tokenDecimals, chainId){\n      const ROUTER_ADDRESS = \"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n      const USDC_ADDRESS = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\";\n     const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"toAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"eventFlag\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"name\": \"depositWei\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n      const erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n      try {\n        const amountInWei = parseUnits(amount, tokenDecimals);\n        await writeContractAsync({ address: USDC_ADDRESS, abi: erc20Abi, functionName: \"approve\", args: [ROUTER_ADDRESS, amountInWei], chainId });\n        const dolomite = new ethers.Contract(\"0x003Ca23Fd5F0ca87D01F6eC6CD14A8AE60c2b97D\", [\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"], new ethers.JsonRpcProvider(\"https://eth.rpc.blxrbdn.com\"));\n        const marketId = await dolomite.getMarketIdByTokenAddress(USDC_ADDRESS);\n        const txHash = await writeContractAsync({ address: ROUTER_ADDRESS, abi: routerAbi, functionName: \"depositWei\", args: [0,0,marketId,amountInWei,0], chainId });\n        return { success: true, txHash };\n      } catch(err){\n        return { success: false, error: err.message || \"Deposit failed\" };\n      }\n    })",
  "withdraw": "(async function withdraw(amount, address, tokenDecimals, chainId){\n      const ROUTER_ADDRESS = \"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n      const USDC_ADDRESS = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\";\n      const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fromAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n      try {\n        const amountInWei = amount===\"max\"?MaxUint256:parseUnits(amount,tokenDecimals);\n        if(amountInWei===0n) throw new Error(\"Cannot withdraw 0\");\n        const dolomite = new ethers.Contract(\"0x003Ca23Fd5F0ca87D01F6eC6CD14A8AE60c2b97D\", [\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"], new ethers.JsonRpcProvider(\"https://eth.rpc.blxrbdn.com\"));\n        const marketId = await dolomite.getMarketIdByTokenAddress(USDC_ADDRESS);\n        const txHash = await writeContractAsync({ address: ROUTER_ADDRESS, abi: routerAbi, functionName:\"withdraw\", args:[0,0,marketId,amountInWei], chainId });\n        return { success: true, txHash };\n      } catch(err){\n        return { success:false, error:err.message||\"Withdraw failed\" };\n      }\n    })",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c3fe9566eaae5f28322069"
  },
  "asset": {
    "$oid": "68b14b85f55db3d0dfa7df62"
  },
  "protocol": {
    "$oid": "68c3cfbf8f07c736ffcad23e"
  },
  "underlyingAsset": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
  "yieldBearingToken": "0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf",
  "apy": "(async function(ethers){\n      const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n      const provider = new ethers.JsonRpcProvider(RPC_URL);\n      const DOLOMITE_MARGIN = \"0x003Ca23Fd5F0ca87D01F6eC6CD14A8AE60c2b97D\";\n      const USDT_ADDRESS = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\";\n      const dolomiteAbi = [\"function getMarketIdByTokenAddress(address token) view returns (uint256)\", \"function getMarketInterestRate(uint256 marketId) view returns (tuple(uint256 value))\", \"function getEarningsRate() view returns (tuple(uint256 value))\"];\n      const dolomite = new ethers.Contract(DOLOMITE_MARGIN, dolomiteAbi, provider);\n      try {\n        const marketId = await dolomite.getMarketIdByTokenAddress(USDT_ADDRESS);\n        const rateStruct = await dolomite.getMarketInterestRate(marketId);\n        const borrowRatePerSecond = Number(rateStruct.value)/1e18;\n        const earningsStruct = await dolomite.getEarningsRate();\n        const earningsRate = Number(earningsStruct.value)/1e18;\n        const SECONDS_PER_YEAR = 60*60*24*365;\n        const aprToApy = (rate) => ((Math.pow(1+rate, SECONDS_PER_YEAR)-1)*100).toFixed(2);\n        const borrowApy = aprToApy(borrowRatePerSecond);\n        const supplyApy = (parseFloat(borrowApy)*earningsRate).toFixed(2);\n        return { borrowApy, apy: supplyApy };\n      } catch(err){\n        return { borrowApy:null, apy:null };\n      }\n    })",
  "deposit": "(async function deposit(amount, address, tokenDecimals, chainId){\n      const ROUTER_ADDRESS = \"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n      const USDT_ADDRESS = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\";\n      const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"toAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"eventFlag\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"name\": \"depositWei\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n      const erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n      try {\n        const amountInWei=parseUnits(amount,tokenDecimals);\n        await writeContractAsync({address:USDT_ADDRESS,abi:erc20Abi,functionName:\"approve\",args:[ROUTER_ADDRESS,amountInWei],chainId});\n        const dolomite=new ethers.Contract(\"0x003Ca23Fd5F0ca87D01F6eC6CD14A8AE60c2b97D\",[\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"],new ethers.JsonRpcProvider(\"https://eth.rpc.blxrbdn.com\"));\n        const marketId=await dolomite.getMarketIdByTokenAddress(USDT_ADDRESS);\n        const txHash=await writeContractAsync({address:ROUTER_ADDRESS,abi:routerAbi,functionName:\"depositWei\",args:[0,0,marketId,amountInWei,0],chainId});\n        return {success:true,txHash};\n      } catch(err){\n        return {success:false,error:err.message||\"Deposit failed\"};\n      }\n    })",
  "withdraw": "(async function withdraw(amount, address, tokenDecimals, chainId){\n      const ROUTER_ADDRESS=\"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n      const USDT_ADDRESS=\"0xdAC17F958D2ee523a2206206994597C13D831ec7\";\n      const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fromAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n      try {\n        const amountInWei=amount===\"max\"?MaxUint256:parseUnits(amount,tokenDecimals);\n        if(amountInWei===0n)throw new Error(\"Cannot withdraw 0\");\n        const dolomite=new ethers.Contract(\"0x003Ca23Fd5F0ca87D01F6eC6CD14A8AE60c2b97D\",[\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"],new ethers.JsonRpcProvider(\"https://eth.rpc.blxrbdn.com\"));\n        const marketId=await dolomite.getMarketIdByTokenAddress(USDT_ADDRESS);\n        const txHash=await writeContractAsync({address:ROUTER_ADDRESS,abi:routerAbi,functionName:\"withdraw\",args:[0,0,marketId,amountInWei],chainId});\n        return {success:true,txHash};\n      } catch(err){\n        return {success:false,error:err.message||\"Withdraw failed\"};\n      }\n    })",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c3fe9566eaae5f2832206a"
  },
  "asset": {
    "$oid": "68b14c95f55db3d0dfa7df70"
  },
  "protocol": {
    "$oid": "68c3cfbf8f07c736ffcad23e"
  },
  "underlyingAsset": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
  "yieldBearingToken": "0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf",
  "apy": "(async function(ethers){\n      const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n      const provider = new ethers.JsonRpcProvider(RPC_URL);\n      const DOLOMITE_MARGIN = \"0x003Ca23Fd5F0ca87D01F6eC6CD14A8AE60c2b97D\";\n      const DAI_ADDRESS = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\";\n      const dolomiteAbi = [\"function getMarketIdByTokenAddress(address token) view returns (uint256)\", \"function getMarketInterestRate(uint256 marketId) view returns (tuple(uint256 value))\", \"function getEarningsRate() view returns (tuple(uint256 value))\"];\n      const dolomite = new ethers.Contract(DOLOMITE_MARGIN, dolomiteAbi, provider);\n      try {\n        const marketId = await dolomite.getMarketIdByTokenAddress(DAI_ADDRESS);\n        const rateStruct = await dolomite.getMarketInterestRate(marketId);\n        const borrowRatePerSecond = Number(rateStruct.value)/1e18;\n        const earningsStruct = await dolomite.getEarningsRate();\n        const earningsRate = Number(earningsStruct.value)/1e18;\n        const SECONDS_PER_YEAR = 60*60*24*365;\n        const aprToApy = (rate) => ((Math.pow(1+rate, SECONDS_PER_YEAR)-1)*100).toFixed(2);\n        const borrowApy = aprToApy(borrowRatePerSecond);\n        const supplyApy = (parseFloat(borrowApy)*earningsRate).toFixed(2);\n        return { borrowApy, apy: supplyApy };\n      } catch(err){\n        return {borrowApy:null, apy:null};\n      }\n    })",
  "deposit": "(async function deposit(amount, address, tokenDecimals, chainId){\n      const ROUTER_ADDRESS=\"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n      const DAI_ADDRESS=\"0x6B175474E89094C44Da98b954EedeAC495271d0F\";\n      const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"toAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"eventFlag\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"name\": \"depositWei\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n      const erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n      try{\n        const amountInWei=parseUnits(amount,tokenDecimals);\n        await writeContractAsync({address:DAI_ADDRESS,abi:erc20Abi,functionName:\"approve\",args:[ROUTER_ADDRESS,amountInWei],chainId});\n        const dolomite=new ethers.Contract(\"0x003Ca23Fd5F0ca87D01F6eC6CD14A8AE60c2b97D\",[\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"],new ethers.JsonRpcProvider(\"https://eth.rpc.blxrbdn.com\"));\n        const marketId=await dolomite.getMarketIdByTokenAddress(DAI_ADDRESS);\n        const txHash=await writeContractAsync({address:ROUTER_ADDRESS,abi:routerAbi,functionName:\"depositWei\",args:[0,0,marketId,amountInWei,0],chainId});\n        return {success:true,txHash};\n      }catch(err){return {success:false,error:err.message||\"Deposit failed\"};}\n    })",
  "withdraw": "(async function withdraw(amount, address, tokenDecimals, chainId){\n      const ROUTER_ADDRESS=\"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n      const DAI_ADDRESS=\"0x6B175474E89094C44Da98b954EedeAC495271d0F\";\n      const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fromAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n      try{\n        const amountInWei=amount===\"max\"?MaxUint256:parseUnits(amount,tokenDecimals);\n        if(amountInWei===0n)throw new Error(\"Cannot withdraw 0\");\n        const dolomite=new ethers.Contract(\"0x003Ca23Fd5F0ca87D01F6eC6CD14A8AE60c2b97D\",[\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"],new ethers.JsonRpcProvider(\"https://eth.rpc.blxrbdn.com\"));\n        const marketId=await dolomite.getMarketIdByTokenAddress(DAI_ADDRESS);\n        const txHash=await writeContractAsync({address:ROUTER_ADDRESS,abi:routerAbi,functionName:\"withdraw\",args:[0,0,marketId,amountInWei],chainId});\n        return {success:true,txHash};\n      }catch(err){return {success:false,error:err.message||\"Withdraw failed\"};}\n    })",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c3fe9566eaae5f2832206b"
  },
  "asset": {
    "$oid": "68b14c85f55db3d0dfa7df6f"
  },
  "protocol": {
    "$oid": "68c3cfbf8f07c736ffcad23e"
  },
  "underlyingAsset": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  "yieldBearingToken": "0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf",
  "apy": "(async function(ethers){\n      const RPC_URL=\"https://eth.rpc.blxrbdn.com\";\n      const provider=new ethers.JsonRpcProvider(RPC_URL);\n      const DOLOMITE_MARGIN=\"0x003Ca23Fd5F0ca87D01F6eC6CD14A8AE60c2b97D\";\n      const WETH_ADDRESS=\"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\";\n      const dolomiteAbi=[\"function getMarketIdByTokenAddress(address token) view returns (uint256)\",\"function getMarketInterestRate(uint256 marketId) view returns (tuple(uint256 value))\",\"function getEarningsRate() view returns (tuple(uint256 value))\"];\n      const dolomite=new ethers.Contract(DOLOMITE_MARGIN,dolomiteAbi,provider);\n      try{\n        const marketId=await dolomite.getMarketIdByTokenAddress(WETH_ADDRESS);\n        const rateStruct=await dolomite.getMarketInterestRate(marketId);\n        const borrowRatePerSecond=Number(rateStruct.value)/1e18;\n        const earningsStruct=await dolomite.getEarningsRate();\n        const earningsRate=Number(earningsStruct.value)/1e18;\n        const SECONDS_PER_YEAR=60*60*24*365;\n        const aprToApy=(rate)=>(Math.pow(1+rate,SECONDS_PER_YEAR)-1)*100;\n        const borrowApy=aprToApy(borrowRatePerSecond);\n        const supplyApy=(borrowApy*earningsRate).toFixed(2);\n        return {borrowApy,apy:supplyApy};\n      }catch(err){return {borrowApy:null,apy:null};}\n    })",
  "deposit": "(async function deposit(amount,address,tokenDecimals,chainId){\n      const ROUTER_ADDRESS=\"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n      const WETH_ADDRESS=\"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\";\n      const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"toAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"eventFlag\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"name\": \"depositWei\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n      const erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n      try{\n        const amountInWei=parseUnits(amount,tokenDecimals);\n        await writeContractAsync({address:WETH_ADDRESS,abi:erc20Abi,functionName:\"approve\",args:[ROUTER_ADDRESS,amountInWei],chainId});\n        const dolomite=new ethers.Contract(\"0x003Ca23Fd5F0ca87D01F6eC6CD14A8AE60c2b97D\",[\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"],new ethers.JsonRpcProvider(\"https://eth.rpc.blxrbdn.com\"));\n        const marketId=await dolomite.getMarketIdByTokenAddress(WETH_ADDRESS);\n        const txHash=await writeContractAsync({address:ROUTER_ADDRESS,abi:routerAbi,functionName:\"depositWei\",args:[0,0,marketId,amountInWei,0],chainId});\n        return {success:true,txHash};\n      }catch(err){return {success:false,error:err.message||\"Deposit failed\"};}\n    })",
  "withdraw": "(async function withdraw(amount,address,tokenDecimals,chainId){\n      const ROUTER_ADDRESS=\"0xf8b2c637A68cF6A17b1DF9F8992EeBeFf63d2dFf\";\n      const WETH_ADDRESS=\"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\";\n      const routerAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"isolationModeMarketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fromAccountNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"marketId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountWei\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n      try{\n        const amountInWei=amount===\"max\"?MaxUint256:parseUnits(amount,tokenDecimals);\n        if(amountInWei===0n)throw new Error(\"Cannot withdraw 0\");\n        const dolomite=new ethers.Contract(\"0x003Ca23Fd5F0ca87D01F6eC6CD14A8AE60c2b97D\",[\"function getMarketIdByTokenAddress(address token) view returns (uint256)\"],new ethers.JsonRpcProvider(\"https://eth.rpc.blxrbdn.com\"));\n        const marketId=await dolomite.getMarketIdByTokenAddress(WETH_ADDRESS);\n        const txHash=await writeContractAsync({address:ROUTER_ADDRESS,abi:routerAbi,functionName:\"withdraw\",args:[0,0,marketId,amountInWei],chainId});\n        return {success:true,txHash};\n      }catch(err){return {success:false,error:err.message||\"Withdraw failed\"};}\n    })",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c41317d0b63e39e3bd2905"
  },
  "asset": {
    "$oid": "68b14b6bf55db3d0dfa7df5e"
  },
  "protocol": {
    "$oid": "68c412ced0b63e39e3bd2904"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // fUSDC contract (Flux USDC market)\n  const FUSDC = \"0x465a5a630482f3abD6d3b84B39B29b07214d19e5\";\n\n  const fTokenAbi = [\n    \"function supplyRatePerBlock() view returns (uint256)\",\n    \"function borrowRatePerBlock() view returns (uint256)\"\n  ];\n\n  const fUSDC = new ethers.Contract(FUSDC, fTokenAbi, provider);\n\n  try {\n    const supplyRatePerBlock = await fUSDC.supplyRatePerBlock();\n    const borrowRatePerBlock = await fUSDC.borrowRatePerBlock();\n\n    // Ethereum ~ 7200 blocks per day\n    const blocksPerYear = 7200 * 365;\n\n    function rateToAPY(ratePerBlock) {\n      return (\n        (Math.pow(1 + Number(ratePerBlock) / 1e18, blocksPerYear) - 1) * 100\n      ).toFixed(2);\n    }\n\n    const supplyApy = rateToAPY(supplyRatePerBlock);\n    const borrowApy = rateToAPY(borrowRatePerBlock);\n\n    console.log(`Flux fUSDC Supply APY: ${supplyApy}%`);\n    console.log(`Flux fUSDC Borrow APY: ${borrowApy}%`);\n\n    return { apy: supplyApy, borrowApy };\n  } catch (err) {\n    console.error(\"Error fetching Flux APY:\", err.message);\n    return { apy: null, borrowApy: null };\n  }\n});\n",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId, mode = \"underlying\") {\n  const FUSDC = \"0x465a5a630482f3abD6d3b84B39B29b07214d19e5\"; // fUSDC\n\n  const fTokenAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"redeemTokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"redeem\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"redeemAmount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"redeemUnderlying\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    let txHash;\n    if (mode === \"underlying\") {\n      // Withdraw exact USDC amount\n      txHash = await writeContractAsync({\n        address: FUSDC,\n        abi: fTokenAbi,\n        functionName: \"redeemUnderlying\",\n        args: [amountInWei],\n        chainId\n      });\n    } else {\n      // Redeem fUSDC tokens directly\n      txHash = await writeContractAsync({\n        address: FUSDC,\n        abi: fTokenAbi,\n        functionName: \"redeem\",\n        args: [amountInWei],\n        chainId\n      });\n    }\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const FUSDC = \"0x465a5a630482f3abD6d3b84B39B29b07214d19e5\"; // fUSDC\n  const USDC = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"; // USDC\n\n  const fTokenAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"mintAmount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"mint\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\nconst erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Step 1: Approve fUSDC\n    const approveTx = await writeContractAsync({\n      address: USDC,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [FUSDC, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Step 2: Mint fUSDC\n    const txHash = await writeContractAsync({\n      address: FUSDC,\n      abi: fTokenAbi,\n      functionName: \"mint\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  "yieldBearingToken": "0x465a5a630482f3abD6d3b84B39B29b07214d19e5",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c416a9e3012951ce9fc863"
  },
  "asset": {
    "$oid": "68b14b85f55db3d0dfa7df62"
  },
  "protocol": {
    "$oid": "68c412ced0b63e39e3bd2904"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // fUSDC contract (Flux USDC market)\n  const FUSDC = \"0x81994b9607e06ab3d5cF3AffF9a67374f05F27d7\";\n\n  const fTokenAbi = [\n    \"function supplyRatePerBlock() view returns (uint256)\",\n    \"function borrowRatePerBlock() view returns (uint256)\"\n  ];\n\n  const fUSDC = new ethers.Contract(FUSDC, fTokenAbi, provider);\n\n  try {\n    const supplyRatePerBlock = await fUSDC.supplyRatePerBlock();\n    const borrowRatePerBlock = await fUSDC.borrowRatePerBlock();\n\n    // Ethereum ~ 7200 blocks per day\n    const blocksPerYear = 7200 * 365;\n\n    function rateToAPY(ratePerBlock) {\n      return (\n        (Math.pow(1 + Number(ratePerBlock) / 1e18, blocksPerYear) - 1) * 100\n      ).toFixed(2);\n    }\n\n    const supplyApy = rateToAPY(supplyRatePerBlock);\n    const borrowApy = rateToAPY(borrowRatePerBlock);\n\n    console.log(`Flux fUSDC Supply APY: ${supplyApy}%`);\n    console.log(`Flux fUSDC Borrow APY: ${borrowApy}%`);\n\n    return { apy: supplyApy, borrowApy };\n  } catch (err) {\n    console.error(\"Error fetching Flux APY:\", err.message);\n    return { apy: null, borrowApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId, mode = \"underlying\") {\n  const FUSDC = \"0x81994b9607e06ab3d5cF3AffF9a67374f05F27d7\"; \n\n  const fTokenAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"redeemTokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"redeem\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"redeemAmount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"redeemUnderlying\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    let txHash;\n    if (mode === \"underlying\") {\n      // Withdraw exact USDC amount\n      txHash = await writeContractAsync({\n        address: FUSDC,\n        abi: fTokenAbi,\n        functionName: \"redeemUnderlying\",\n        args: [amountInWei],\n        chainId\n      });\n    } else {\n      // Redeem fUSDC tokens directly\n      txHash = await writeContractAsync({\n        address: FUSDC,\n        abi: fTokenAbi,\n        functionName: \"redeem\",\n        args: [amountInWei],\n        chainId\n      });\n    }\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const FUSDC = \"0x81994b9607e06ab3d5cF3AffF9a67374f05F27d7\"; // fUSDC\n  const USDC = \"0xdac17f958d2ee523a2206206994597c13d831ec7\"; // USDC\n\n  const fTokenAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"mintAmount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"mint\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\nconst erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Step 1: Approve fUSDC\n    const approveTx = await writeContractAsync({\n      address: USDC,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [FUSDC, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Step 2: Mint fUSDC\n    const txHash = await writeContractAsync({\n      address: FUSDC,\n      abi: fTokenAbi,\n      functionName: \"mint\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xdac17f958d2ee523a2206206994597c13d831ec7",
  "yieldBearingToken": "0x81994b9607e06ab3d5cF3AffF9a67374f05F27d7",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c41713e3012951ce9fc865"
  },
  "asset": {
    "$oid": "68b14c95f55db3d0dfa7df70"
  },
  "protocol": {
    "$oid": "68c412ced0b63e39e3bd2904"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  // fUSDC contract (Flux USDC market)\n  const FUSDC = \"0xe2bA8693cE7474900A045757fe0efCa900F6530b\";\n\n  const fTokenAbi = [\n    \"function supplyRatePerBlock() view returns (uint256)\",\n    \"function borrowRatePerBlock() view returns (uint256)\"\n  ];\n\n  const fUSDC = new ethers.Contract(FUSDC, fTokenAbi, provider);\n\n  try {\n    const supplyRatePerBlock = await fUSDC.supplyRatePerBlock();\n    const borrowRatePerBlock = await fUSDC.borrowRatePerBlock();\n\n    // Ethereum ~ 7200 blocks per day\n    const blocksPerYear = 7200 * 365;\n\n    function rateToAPY(ratePerBlock) {\n      return (\n        (Math.pow(1 + Number(ratePerBlock) / 1e18, blocksPerYear) - 1) * 100\n      ).toFixed(2);\n    }\n\n    const supplyApy = rateToAPY(supplyRatePerBlock);\n    const borrowApy = rateToAPY(borrowRatePerBlock);\n\n    console.log(`Flux fUSDC Supply APY: ${supplyApy}%`);\n    console.log(`Flux fUSDC Borrow APY: ${borrowApy}%`);\n\n    return { apy: supplyApy, borrowApy };\n  } catch (err) {\n    console.error(\"Error fetching Flux APY:\", err.message);\n    return { apy: null, borrowApy: null };\n  }\n});",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId, mode = \"underlying\") {\n  const FUSDC = \"0xe2bA8693cE7474900A045757fe0efCa900F6530b\"; \n\n  const fTokenAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"redeemTokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"redeem\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"redeemAmount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"redeemUnderlying\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    let txHash;\n    if (mode === \"underlying\") {\n      // Withdraw exact USDC amount\n      txHash = await writeContractAsync({\n        address: FUSDC,\n        abi: fTokenAbi,\n        functionName: \"redeemUnderlying\",\n        args: [amountInWei],\n        chainId\n      });\n    } else {\n      // Redeem fUSDC tokens directly\n      txHash = await writeContractAsync({\n        address: FUSDC,\n        abi: fTokenAbi,\n        functionName: \"redeem\",\n        args: [amountInWei],\n        chainId\n      });\n    }\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const FUSDC = \"0xe2bA8693cE7474900A045757fe0efCa900F6530b\"; // fUSDC\n  const USDC = \"0x6b175474e89094c44da98b954eedeac495271d0f\"; // USDC\n\n  const fTokenAbi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"mintAmount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"mint\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\nconst erc20Abi = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n];\n\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Step 1: Approve fUSDC\n    const approveTx = await writeContractAsync({\n      address: USDC,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [FUSDC, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Step 2: Mint fUSDC\n    const txHash = await writeContractAsync({\n      address: FUSDC,\n      abi: fTokenAbi,\n      functionName: \"mint\",\n      args: [amountInWei],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x6b175474e89094c44da98b954eedeac495271d0f",
  "yieldBearingToken": "0xe2bA8693cE7474900A045757fe0efCa900F6530b",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c7bb24a18ab4e604db8f35"
  },
  "asset": {
    "$oid": "68b14b6bf55db3d0dfa7df5e"
  },
  "protocol": {
    "$oid": "68c7b648a18ab4e604db8f34"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const STAKING = \"0x622fA41799406B120f9a40dA843D358b7b2CFEE3\";\n  const VAULT = \"0xBe53A109B494E5c9f97b9Cd39Fe969BE68BF6204\";\n  const ORACLE = \"0x1981AD9F44F2EA9aDd2dC4AD7D075c102C70aF92\";\n\n  const oracleAbi = [\n    \"function getCurrentApr(address _vault) view returns (uint256)\"\n  ];\n  const stakingAbi = [\n    \"function rewardRate() view returns (uint256)\",\n    \"function totalSupply() view returns (uint256)\"\n  ];\n\n  try {\n    const oracle = new ethers.Contract(ORACLE, oracleAbi, provider);\n    const staking = new ethers.Contract(STAKING, stakingAbi, provider);\n\n    let aprRaw = await oracle.getCurrentApr(VAULT);\n    const apr = parseFloat(ethers.formatUnits(aprRaw, 18));\n    \n    const n = 365; // daily compounding\n    const vaultAPY = (Math.pow(1 + apr / n, n) - 1) * 100;\n    console.log(\"Vault APY:\", vaultAPY.toFixed(2) + \"%\");\n\n    // --- Staking APR ---\n    const rewardRate = await staking.rewardRate(); // per second\n    const totalStaked = await staking.totalSupply();\n    const secondsPerYear = 365 * 24 * 3600;\n    const rewardsPerYear = Number(rewardRate) * secondsPerYear;\n    const stakingAPR = (rewardsPerYear / Number(totalStaked)) * 100;\n    return {\n      vaultAPY: vaultAPY.toFixed(2) + \"%\",\n      stakingAPR: stakingAPR.toFixed(2) + \"%\",\n      totalAPY: (vaultAPY + stakingAPR).toFixed(2) + \"%\",\n      borrowApy: null,\n      rewardApy: null,\n      apy: vaultAPY.toFixed(2) + \"%\",\n    };\n  } catch (err) {\n    console.error(\"Error fetching Yearn APY:\", err.message);\n    return { apy: null, vaultAPY: null, stakingAPR: null, totalAPY: null };\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId, mode = \"underlying\") {\n  const VAULT = \"0xBe53A109B494E5c9f97b9Cd39Fe969BE68BF6204\";\n\n  const vaultAbi = [\n    {\n      \"type\": \"function\",\n      \"name\": \"withdraw\",\n      \"stateMutability\": \"nonpayable\",\n      \"inputs\": [\n        { \"name\": \"assets\", \"type\": \"uint256\" },\n        { \"name\": \"receiver\", \"type\": \"address\" },\n        { \"name\": \"owner\", \"type\": \"address\" }\n      ],\n      \"outputs\": [\n        { \"name\": \"shares\", \"type\": \"uint256\" }\n      ]\n    },\n    {\n      \"type\": \"function\",\n      \"name\": \"redeem\",\n      \"stateMutability\": \"nonpayable\",\n      \"inputs\": [\n        { \"name\": \"shares\", \"type\": \"uint256\" },\n        { \"name\": \"receiver\", \"type\": \"address\" },\n        { \"name\": \"owner\", \"type\": \"address\" }\n      ],\n      \"outputs\": [\n        { \"name\": \"assets\", \"type\": \"uint256\" }\n      ]\n    }\n  ];\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    let txHash;\n    if (mode === \"underlying\") {\n      // Withdraw by asset amount\n      txHash = await writeContractAsync({\n        address: VAULT,\n        abi: vaultAbi,\n        functionName: \"withdraw\",\n        args: [amountInWei, address, address],\n        chainId\n      });\n    } else {\n      // Redeem vault shares directly\n      txHash = await writeContractAsync({\n        address: VAULT,\n        abi: vaultAbi,\n        functionName: \"redeem\",\n        args: [amountInWei, address, address],\n        chainId\n      });\n    }\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}\n",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const VAULT = \"0xBe53A109B494E5c9f97b9Cd39Fe969BE68BF6204\";\n  const TOKEN = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"; // USDC\n\n  const tokenAbi = [\n    {\n      \"type\": \"function\",\n      \"name\": \"approve\",\n      \"stateMutability\": \"nonpayable\",\n      \"inputs\": [\n        { \"name\": \"spender\", \"type\": \"address\" },\n        { \"name\": \"amount\", \"type\": \"uint256\" }\n      ],\n      \"outputs\": [\n        { \"name\": \"\", \"type\": \"bool\" }\n      ]\n    }\n  ];\n\n  const vaultAbi = [\n    {\n      \"type\": \"function\",\n      \"name\": \"deposit\",\n      \"stateMutability\": \"nonpayable\",\n      \"inputs\": [\n        { \"name\": \"assets\", \"type\": \"uint256\" },\n        { \"name\": \"receiver\", \"type\": \"address\" }\n      ],\n      \"outputs\": [\n        { \"name\": \"shares\", \"type\": \"uint256\" }\n      ]\n    }\n  ];\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Step 1: Approve vault\n    const approveTx = await writeContractAsync({\n      address: TOKEN,\n      abi: tokenAbi,\n      functionName: \"approve\",\n      args: [VAULT, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Step 2: Deposit into vault\n    const txHash = await writeContractAsync({\n      address: VAULT,\n      abi: vaultAbi,\n      functionName: \"deposit\",\n      args: [amountInWei, address],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  "yieldBearingToken": "0xBe53A109B494E5c9f97b9Cd39Fe969BE68BF6204",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c7ecbbc1be70d84e7f238e"
  },
  "asset": {
    "$oid": "68b14c95f55db3d0dfa7df70"
  },
  "protocol": {
    "$oid": "68c7b648a18ab4e604db8f34"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const STAKING = \"0x128e72DfD8b00cbF9d12cB75E846AC87B83DdFc9\";\n  const VAULT = \"0x028eC7330ff87667b6dfb0D94b954c820195336c\";\n  const ORACLE = \"0x1981AD9F44F2EA9aDd2dC4AD7D075c102C70aF92\";\n\n  const oracleAbi = [\n    \"function getCurrentApr(address _vault) view returns (uint256)\"\n  ];\n  const stakingAbi = [\n    \"function rewardRate() view returns (uint256)\",\n    \"function totalSupply() view returns (uint256)\"\n  ];\n\n  try {\n    const oracle = new ethers.Contract(ORACLE, oracleAbi, provider);\n    const staking = new ethers.Contract(STAKING, stakingAbi, provider);\n\n    let aprRaw = await oracle.getCurrentApr(VAULT);\n    const apr = parseFloat(ethers.formatUnits(aprRaw, 18));\n    \n    const n = 365; // daily compounding\n    const vaultAPY = (Math.pow(1 + apr / n, n) - 1) * 100;\n    console.log(\"Vault APY:\", vaultAPY.toFixed(2) + \"%\");\n\n    // --- Staking APR ---\n    const rewardRate = await staking.rewardRate(); // per second\n    const totalStaked = await staking.totalSupply();\n    const secondsPerYear = 365 * 24 * 3600;\n    const rewardsPerYear = Number(rewardRate) * secondsPerYear;\n    const stakingAPR = (rewardsPerYear / Number(totalStaked)) * 100;\n    return {\n      vaultAPY: vaultAPY.toFixed(2) + \"%\",\n      stakingAPR: stakingAPR.toFixed(2) + \"%\",\n      totalAPY: (vaultAPY + stakingAPR).toFixed(2) + \"%\",\n      borrowApy: null,\n      rewardApy: null,\n      apy: vaultAPY.toFixed(2) + \"%\",\n    };\n  } catch (err) {\n    console.error(\"Error fetching Yearn APY:\", err.message);\n    return { apy: null, vaultAPY: null, stakingAPR: null, totalAPY: null };\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId, mode = \"underlying\") {\n  const VAULT = \"0x028eC7330ff87667b6dfb0D94b954c820195336c\";\n\n  const vaultAbi = [\n  {\n    \"inputs\": [\n      { \"internalType\": \"uint256\", \"name\": \"assets\", \"type\": \"uint256\" },\n      { \"internalType\": \"address\", \"name\": \"receiver\", \"type\": \"address\" },\n      { \"internalType\": \"address\", \"name\": \"owner\", \"type\": \"address\" }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [\n      { \"internalType\": \"uint256\", \"name\": \"shares\", \"type\": \"uint256\" }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      { \"internalType\": \"uint256\", \"name\": \"shares\", \"type\": \"uint256\" },\n      { \"internalType\": \"address\", \"name\": \"receiver\", \"type\": \"address\" },\n      { \"internalType\": \"address\", \"name\": \"owner\", \"type\": \"address\" }\n    ],\n    \"name\": \"redeem\",\n    \"outputs\": [\n      { \"internalType\": \"uint256\", \"name\": \"assets\", \"type\": \"uint256\" }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    let txHash;\n    if (mode === \"underlying\") {\n      // Withdraw by asset amount\n      txHash = await writeContractAsync({\n        address: VAULT,\n        abi: vaultAbi,\n        functionName: \"withdraw\",\n        args: [amountInWei, address, address],\n        chainId\n      });\n    } else {\n      // Redeem vault shares directly\n      txHash = await writeContractAsync({\n        address: VAULT,\n        abi: vaultAbi,\n        functionName: \"redeem\",\n        args: [amountInWei, address, address],\n        chainId\n      });\n    }\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const VAULT = \"0x028eC7330ff87667b6dfb0D94b954c820195336c\";\n  const TOKEN = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"; // USDC\n\n  const tokenAbi = [\n    {\n      \"type\": \"function\",\n      \"name\": \"approve\",\n      \"stateMutability\": \"nonpayable\",\n      \"inputs\": [\n        { \"name\": \"spender\", \"type\": \"address\" },\n        { \"name\": \"amount\", \"type\": \"uint256\" }\n      ],\n      \"outputs\": [\n        { \"name\": \"\", \"type\": \"bool\" }\n      ]\n    }\n  ];\n\n  const vaultAbi = [\n    {\n      \"type\": \"function\",\n      \"name\": \"deposit\",\n      \"stateMutability\": \"nonpayable\",\n      \"inputs\": [\n        { \"name\": \"assets\", \"type\": \"uint256\" },\n        { \"name\": \"receiver\", \"type\": \"address\" }\n      ],\n      \"outputs\": [\n        { \"name\": \"shares\", \"type\": \"uint256\" }\n      ]\n    }\n  ];\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Step 1: Approve vault\n    const approveTx = await writeContractAsync({\n      address: TOKEN,\n      abi: tokenAbi,\n      functionName: \"approve\",\n      args: [VAULT, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Step 2: Deposit into vault\n    const txHash = await writeContractAsync({\n      address: VAULT,\n      abi: vaultAbi,\n      functionName: \"deposit\",\n      args: [amountInWei, address],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
  "yieldBearingToken": "0x028eC7330ff87667b6dfb0D94b954c820195336c",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c7ed6fc1be70d84e7f238f"
  },
  "asset": {
    "$oid": "68b14c85f55db3d0dfa7df6f"
  },
  "protocol": {
    "$oid": "68c7b648a18ab4e604db8f34"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const STAKING = \"0x5943F7090282Eb66575662EADf7C60a717a7cE4D\";\n  const VAULT = \"0xc56413869c6CDf96496f2b1eF801fEDBdFA7dDB0\";\n  const ORACLE = \"0x1981AD9F44F2EA9aDd2dC4AD7D075c102C70aF92\";\n\n  const oracleAbi = [\n    \"function getCurrentApr(address _vault) view returns (uint256)\"\n  ];\n  const stakingAbi = [\n    \"function rewardRate() view returns (uint256)\",\n    \"function totalSupply() view returns (uint256)\"\n  ];\n\n  try {\n    const oracle = new ethers.Contract(ORACLE, oracleAbi, provider);\n    const staking = new ethers.Contract(STAKING, stakingAbi, provider);\n\n    let aprRaw = await oracle.getCurrentApr(VAULT);\n    const apr = parseFloat(ethers.formatUnits(aprRaw, 18));\n    \n    const n = 365; // daily compounding\n    const vaultAPY = (Math.pow(1 + apr / n, n) - 1) * 100;\n    console.log(\"Vault APY:\", vaultAPY.toFixed(2) + \"%\");\n\n    // --- Staking APR ---\n    const rewardRate = await staking.rewardRate(); // per second\n    const totalStaked = await staking.totalSupply();\n    const secondsPerYear = 365 * 24 * 3600;\n    const rewardsPerYear = Number(rewardRate) * secondsPerYear;\n    const stakingAPR = (rewardsPerYear / Number(totalStaked)) * 100;\n    return {\n      vaultAPY: vaultAPY.toFixed(2) + \"%\",\n      stakingAPR: stakingAPR.toFixed(2) + \"%\",\n      totalAPY: (vaultAPY + stakingAPR).toFixed(2) + \"%\",\n      borrowApy: null,\n      rewardApy: null,\n      apy: vaultAPY.toFixed(2) + \"%\",\n    };\n  } catch (err) {\n    console.error(\"Error fetching Yearn APY:\", err.message);\n    return { apy: null, vaultAPY: null, stakingAPR: null, totalAPY: null };\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId, mode = \"underlying\") {\n  const VAULT = \"0xc56413869c6CDf96496f2b1eF801fEDBdFA7dDB0\";\n\n  const vaultAbi = [\n  {\n    \"inputs\": [\n      { \"internalType\": \"uint256\", \"name\": \"assets\", \"type\": \"uint256\" },\n      { \"internalType\": \"address\", \"name\": \"receiver\", \"type\": \"address\" },\n      { \"internalType\": \"address\", \"name\": \"owner\", \"type\": \"address\" }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [\n      { \"internalType\": \"uint256\", \"name\": \"shares\", \"type\": \"uint256\" }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      { \"internalType\": \"uint256\", \"name\": \"shares\", \"type\": \"uint256\" },\n      { \"internalType\": \"address\", \"name\": \"receiver\", \"type\": \"address\" },\n      { \"internalType\": \"address\", \"name\": \"owner\", \"type\": \"address\" }\n    ],\n    \"name\": \"redeem\",\n    \"outputs\": [\n      { \"internalType\": \"uint256\", \"name\": \"assets\", \"type\": \"uint256\" }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    let txHash;\n    if (mode === \"underlying\") {\n      // Withdraw by asset amount\n      txHash = await writeContractAsync({\n        address: VAULT,\n        abi: vaultAbi,\n        functionName: \"withdraw\",\n        args: [amountInWei, address, address],\n        chainId\n      });\n    } else {\n      // Redeem vault shares directly\n      txHash = await writeContractAsync({\n        address: VAULT,\n        abi: vaultAbi,\n        functionName: \"redeem\",\n        args: [amountInWei, address, address],\n        chainId\n      });\n    }\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const VAULT = \"0xc56413869c6CDf96496f2b1eF801fEDBdFA7dDB0\";\n  const TOKEN = \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\"; // WETH\n\n  const tokenAbi = [\n    {\n      \"type\": \"function\",\n      \"name\": \"approve\",\n      \"stateMutability\": \"nonpayable\",\n      \"inputs\": [\n        { \"name\": \"spender\", \"type\": \"address\" },\n        { \"name\": \"amount\", \"type\": \"uint256\" }\n      ],\n      \"outputs\": [\n        { \"name\": \"\", \"type\": \"bool\" }\n      ]\n    }\n  ];\n\n  const vaultAbi = [\n    {\n      \"type\": \"function\",\n      \"name\": \"deposit\",\n      \"stateMutability\": \"nonpayable\",\n      \"inputs\": [\n        { \"name\": \"assets\", \"type\": \"uint256\" },\n        { \"name\": \"receiver\", \"type\": \"address\" }\n      ],\n      \"outputs\": [\n        { \"name\": \"shares\", \"type\": \"uint256\" }\n      ]\n    }\n  ];\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Step 1: Approve vault\n    const approveTx = await writeContractAsync({\n      address: TOKEN,\n      abi: tokenAbi,\n      functionName: \"approve\",\n      args: [VAULT, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Step 2: Deposit into vault\n    const txHash = await writeContractAsync({\n      address: VAULT,\n      abi: vaultAbi,\n      functionName: \"deposit\",\n      args: [amountInWei, address],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  "yieldBearingToken": "0xc56413869c6CDf96496f2b1eF801fEDBdFA7dDB0",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68c7f65dfed320db49bbdd78"
  },
  "asset": {
    "$oid": "68b14b85f55db3d0dfa7df62"
  },
  "protocol": {
    "$oid": "68c7b648a18ab4e604db8f34"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const VAULT = \"0x310B7Ea7475A0B449Cfd73bE81522F1B88eFAFaa\";\n  const ORACLE = \"0x1981AD9F44F2EA9aDd2dC4AD7D075c102C70aF92\";\n\n  const oracleAbi = [\n    \"function getCurrentApr(address _vault) view returns (uint256)\"\n  ];\n\n\n  try {\n    const oracle = new ethers.Contract(ORACLE, oracleAbi, provider);\n\n    let aprRaw = await oracle.getCurrentApr(VAULT);\n    const apr = parseFloat(ethers.formatUnits(aprRaw, 18));\n    \n    const n = 365; // daily compounding\n    const vaultAPY = (Math.pow(1 + apr / n, n) - 1) * 100;\n    console.log(\"Vault APY:\", vaultAPY.toFixed(2) + \"%\");\n\n    return {\n      vaultAPY: vaultAPY.toFixed(2) + \"%\",\n      stakingAPR: null,\n      totalAPY: vaultAPY.toFixed(2) + \"%\",\n      borrowApy: null,\n      rewardApy: null,\n      apy: vaultAPY.toFixed(2) + \"%\",\n    };\n  } catch (err) {\n    console.error(\"Error fetching Yearn APY:\", err.message);\n    return { apy: null, vaultAPY: null, stakingAPR: null, totalAPY: null };\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId, mode = \"underlying\") {\n  const VAULT = \"0x310B7Ea7475A0B449Cfd73bE81522F1B88eFAFaa\";\n\n  const vaultAbi = [\n    {\n      \"inputs\": [\n        { \"internalType\": \"uint256\", \"name\": \"assets\", \"type\": \"uint256\" },\n        { \"internalType\": \"address\", \"name\": \"receiver\", \"type\": \"address\" },\n        { \"internalType\": \"address\", \"name\": \"owner\", \"type\": \"address\" }\n      ],\n      \"name\": \"withdraw\",\n      \"outputs\": [\n        { \"internalType\": \"uint256\", \"name\": \"shares\", \"type\": \"uint256\" }\n      ],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        { \"internalType\": \"uint256\", \"name\": \"shares\", \"type\": \"uint256\" },\n        { \"internalType\": \"address\", \"name\": \"receiver\", \"type\": \"address\" },\n        { \"internalType\": \"address\", \"name\": \"owner\", \"type\": \"address\" }\n      ],\n      \"name\": \"redeem\",\n      \"outputs\": [\n        { \"internalType\": \"uint256\", \"name\": \"assets\", \"type\": \"uint256\" }\n      ],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    }\n  ]\n\n  try {\n    const amountInWei =\n      amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    let txHash;\n    if (mode === \"underlying\") {\n      // Withdraw by asset amount\n      txHash = await writeContractAsync({\n        address: VAULT,\n        abi: vaultAbi,\n        functionName: \"withdraw\",\n        args: [amountInWei, address, address],\n        chainId\n      });\n    } else {\n      // Redeem vault shares directly\n      txHash = await writeContractAsync({\n        address: VAULT,\n        abi: vaultAbi,\n        functionName: \"redeem\",\n        args: [amountInWei, address, address],\n        chainId\n      });\n    }\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId) {\n  const VAULT = \"0x310B7Ea7475A0B449Cfd73bE81522F1B88eFAFaa\";\n  const TOKEN = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\"; // USDT\n\n  const tokenAbi = [\n    {\n      \"type\": \"function\",\n      \"name\": \"approve\",\n      \"stateMutability\": \"nonpayable\",\n      \"inputs\": [\n        { \"name\": \"spender\", \"type\": \"address\" },\n        { \"name\": \"amount\", \"type\": \"uint256\" }\n      ],\n      \"outputs\": [\n        { \"name\": \"\", \"type\": \"bool\" }\n      ]\n    }\n  ];\n\n  const vaultAbi = [\n    {\n      \"type\": \"function\",\n      \"name\": \"deposit\",\n      \"stateMutability\": \"nonpayable\",\n      \"inputs\": [\n        { \"name\": \"assets\", \"type\": \"uint256\" },\n        { \"name\": \"receiver\", \"type\": \"address\" }\n      ],\n      \"outputs\": [\n        { \"name\": \"shares\", \"type\": \"uint256\" }\n      ]\n    }\n  ];\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Step 1: Approve vault\n    const approveTx = await writeContractAsync({\n      address: TOKEN,\n      abi: tokenAbi,\n      functionName: \"approve\",\n      args: [VAULT, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Step 2: Deposit into vault\n    const txHash = await writeContractAsync({\n      address: VAULT,\n      abi: vaultAbi,\n      functionName: \"deposit\",\n      args: [amountInWei, address],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
  "yieldBearingToken": "0x4Bd05E6ff75b633F504F0fC501c1e257578C8A72",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68cbbadfd56874f9edd20811"
  },
  "asset": {
    "$oid": "68cbb6b29892471ecbaeaf43"
  },
  "protocol": {
    "$oid": "68cbb6f89892471ecbaeaf44"
  },
  "apy": "(async function (ethers) {\n  const RPC_URL = \"https://eth.rpc.blxrbdn.com\";\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const POOL = \"0x25121EDDf746c884ddE4619b573A7B10714E2a36\"; // ILV pool\n\n  const poolAbi = [\n    \"function yieldRewardsPerWeight() view returns (uint256)\",\n    \"function usersLockingWeight() view returns (uint256)\"\n  ];\n\n  try {\n    const pool = new ethers.Contract(POOL, poolAbi, provider);\n\n    const rewardPerWeight = await pool.yieldRewardsPerWeight();\n    const lockingWeight = await pool.usersLockingWeight();\n\n    // simplified APR calc\n    const apr = Number(rewardPerWeight) / Number(lockingWeight);\n    const n = 365;\n    const apy = (Math.pow(1 + apr / n, n) - 1) * 100;\nconsole.log(\"Reward Per Weight:\", apr);\n    console.log(\"Illuvium APY:\", apy + \"%\");\n    return {\n      borrowApy: null,\n      rewardApy: null,\n      apy: apy.toFixed(2) + \"%\",\n    };\n  } catch (err) {\n    console.error(\"Error fetching Illuvium APY:\", err.message);\n    return { apy: null, vaultAPY: null, stakingAPR: null, totalAPY: null };\n  }\n})",
  "withdraw": "async function withdraw(amount, address, tokenDecimals, chainId, useSILV = false) {\n  const POOL = \"0x25121EDDf746c884ddE4619b573A7B10714E2a36\"; // ILV Pool\n\n  const poolAbi = [\n    {\n      \"type\": \"function\",\n      \"name\": \"unstake\",\n      \"stateMutability\": \"nonpayable\",\n      \"inputs\": [\n        { \"name\": \"_depositId\", \"type\": \"uint256\" },\n        { \"name\": \"_amount\", \"type\": \"uint256\" },\n        { \"name\": \"_useSILV\", \"type\": \"bool\" }\n      ],\n      \"outputs\": []\n    },\n    {\n      \"type\": \"function\",\n      \"name\": \"getDepositsLength\",\n      \"stateMutability\": \"view\",\n      \"inputs\": [{ \"name\": \"_user\", \"type\": \"address\" }],\n      \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }]\n    },\n    {\n      \"type\": \"function\",\n      \"name\": \"getDeposit\",\n      \"stateMutability\": \"view\",\n      \"inputs\": [\n        { \"name\": \"_user\", \"type\": \"address\" },\n        { \"name\": \"_depositId\", \"type\": \"uint256\" }\n      ],\n      \"outputs\": [\n        {\n          \"components\": [\n            { \"name\": \"tokenAmount\", \"type\": \"uint256\" },\n            { \"name\": \"weight\", \"type\": \"uint256\" },\n            { \"name\": \"lockedFrom\", \"type\": \"uint64\" },\n            { \"name\": \"lockedUntil\", \"type\": \"uint64\" },\n            { \"name\": \"isYield\", \"type\": \"bool\" }\n          ],\n          \"type\": \"tuple\"\n        }\n      ]\n    }\n  ];\n\n  try {\n    const amountInWei = amount === \"max\" ? MaxUint256 : parseUnits(amount, tokenDecimals);\n    if (amountInWei === 0n) throw new Error(\"Cannot withdraw 0\");\n\n    // 1. Fetch user deposits\n    const provider = new ethers.JsonRpcProvider(\"https://eth.llamarpc.com\"); // Ethereum mainnet RPC\n    const pool = new ethers.Contract(POOL, poolAbi, provider);\n\n    const depositLength = await pool.getDepositsLength(address);\n    if (depositLength === 0n) throw new Error(\"User has no deposits\");\n\n    // 2. Pick first active depositId (you can enhance this to filter unlocked ones)\n    let depositIdToUse = null;\n    for (let i = 0n; i < depositLength; i++) {\n      const dep = await pool.getDeposit(address, i);\n      if (dep.tokenAmount > 0n) {\n        depositIdToUse = i;\n        break;\n      }\n    }\n    if (depositIdToUse === null) throw new Error(\"No active deposits found\");\n\n    // 3. Call unstake\n    const txHash = await writeContractAsync({\n      address: POOL,\n      abi: poolAbi,\n      functionName: \"unstake\",\n      args: [depositIdToUse, amountInWei, useSILV],\n      chainId\n    });\n\n    return { success: true, txHash, depositIdUsed: depositIdToUse };\n  } catch (err) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "async function deposit(amount, address, tokenDecimals, chainId, lockUntil = 0, useSILV = false) {\n  const POOL = \"0x25121EDDf746c884ddE4619b573A7B10714E2a36\"; // ILV staking pool\n  const ILV = \"0x767FE9EDC9E0DF98e07454847909b5E959D7ca0E\"; // ILV token\n\n  const poolAbi = [\n    {\n      \"inputs\": [\n        { \"internalType\": \"uint256\", \"name\": \"_amount\", \"type\": \"uint256\" },\n        { \"internalType\": \"uint64\", \"name\": \"_lockUntil\", \"type\": \"uint64\" },\n        { \"internalType\": \"bool\", \"name\": \"_useSILV\", \"type\": \"bool\" }\n      ],\n      \"name\": \"stake\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    }\n  ];\n\n  const erc20Abi = [\n    {\n      \"inputs\": [\n        { \"internalType\": \"address\", \"name\": \"spender\", \"type\": \"address\" },\n        { \"internalType\": \"uint256\", \"name\": \"amount\", \"type\": \"uint256\" }\n      ],\n      \"name\": \"approve\",\n      \"outputs\": [\n        { \"internalType\": \"bool\", \"name\": \"\", \"type\": \"bool\" }\n      ],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    }\n  ];\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    // Step 1: Approve pool to spend ILV\n    const approveTx = await writeContractAsync({\n      address: ILV,\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [POOL, amountInWei],\n      chainId\n    });\n    await waitForTransaction({ hash: approveTx, chainId });\n\n    // Step 2: Stake into pool\n    const txHash = await writeContractAsync({\n      address: POOL,\n      abi: poolAbi,\n      functionName: \"stake\",\n      args: [amountInWei, lockUntil, useSILV],\n      chainId\n    });\n\n    return { success: true, txHash };\n  } catch (err) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "0x767FE9EDC9E0DF98e07454847909b5E959D7ca0E",
  "yieldBearingToken": "0x8b4d8443a0229349a9892d4f7cbe89ef5f843f72",
  "withdrawContract": "",
  "withdrawUri": ""
},
{
  "_id": {
    "$oid": "68cbe697d56874f9edd20816"
  },
  "asset": {
    "$oid": "68cbe5a1d56874f9edd20814"
  },
  "protocol": {
    "$oid": "68cbe617d56874f9edd20815"
  },
  "apy": "(async function (ethers) {\n  const STAKING = \"0x7f3E35B41BDF7DBA6a90661918d0EfDDC6C15c3C\"; // replace with actual\n  const RPC_URL = \"https://rpc.winr.games\"; // Arbitrum RPC\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n\n  const stakingAbi = [\n    {\n      name: \"getCurrentEpoch\",\n      type: \"function\",\n      stateMutability: \"view\",\n      inputs: [],\n      outputs: [{ name: \"\", type: \"uint128\" }],\n    },\n    {\n      name: \"totalLockedWINR\",\n      type: \"function\",\n      stateMutability: \"view\",\n      inputs: [],\n      outputs: [{ name: \"\", type: \"uint256\" }],\n    },\n    {\n      name: \"getShareData\",\n      type: \"function\",\n      stateMutability: \"view\",\n      inputs: [\n        { name: \"epoch\", type: \"uint256\" },\n        { name: \"lpToken\", type: \"address\" } // for native WINR, pass 0x000..000\n      ],\n      outputs: [\n        { name: \"reward\", type: \"uint256\" },\n        { name: \"totalWeight\", type: \"uint256\" }\n      ],\n    }\n  ];\n\n  try {\n    const stakingContract = new ethers.Contract(STAKING, stakingAbi, provider);\n\n    const epoch = await stakingContract.getCurrentEpoch();\n    const totalLocked = await stakingContract.totalLockedWINR();\n\n    // Pass zero address for native WINR\n    const { reward, totalWeight } = await stakingContract.getShareData(\n      epoch,\n      \"0x5b02a4B612c1d061BF3542562b173326Ca11C1b4\"\n    );\n    if (totalWeight === 0n || totalLocked === 0n) return { success: true, apy: \"0%\" };\n    const rewardNumber = Number(ethers.formatUnits(reward, 18));\n    const totalLockedNumber = Number(ethers.formatUnits(totalLocked, 18));\n\n    // Weekly reward per staked WINR\n    const weeklyRewardRate = rewardNumber / totalLockedNumber;\n\n    // Convert to daily reward rate\n    const dailyRewardRate = weeklyRewardRate / 7;\n\n    // Apply daily compounding\n    const n = 365;\n    const apy = (Math.pow(1 + dailyRewardRate, n) - 1) * 100;\n\n    return { apy: apy.toFixed(2) + \"%\" };\n  } catch (err) {\n    console.error(\"Error calculating APY:\", err);\n    return { apy: null };\n  }\n})",
  "withdraw": "export async function withdrawWINR(amount: any, address: any, tokenDecimals: any, chainId: any,) {\n  const STAKING = \"0x7f3E35B41BDF7DBA6a90661918d0EfDDC6C15c3C\"; // replace with actual\n\n  const stakingAbi = [\n    {\n      inputs: [{ internalType: \"uint128\", name: \"index\", type: \"uint128\" }],\n      name: \"unlock\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n    {\n      inputs: [{ internalType: \"address\", name: \"user\", type: \"address\" }],\n      name: \"getUserLocksLength\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [\n        { internalType: \"address\", name: \"user\", type: \"address\" },\n        { internalType: \"uint256\", name: \"fromIndex\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"limit\", type: \"uint256\" },\n      ],\n      name: \"getLocks\",\n      outputs: [\n        {\n          components: [\n            { internalType: \"uint64\", name: \"index\", type: \"uint64\" },\n            { internalType: \"uint128\", name: \"amount\", type: \"uint128\" },\n            { internalType: \"uint128\", name: \"fullyAmount\", type: \"uint128\" },\n            { internalType: \"uint128\", name: \"weight\", type: \"uint128\" },\n            { internalType: \"uint128\", name: \"startTime\", type: \"uint128\" },\n            { internalType: \"uint128\", name: \"endTime\", type: \"uint128\" },\n            { internalType: \"uint128\", name: \"lastClaimedEpoch\", type: \"uint128\" },\n            { internalType: \"bool\", name: \"vesting\", type: \"bool\" },\n            { internalType: \"bool\", name: \"withdrawn\", type: \"bool\" },\n          ],\n          internalType: \"struct IWINRLock.LockData[]\",\n          name: \"lockData\",\n          type: \"tuple[]\",\n        },\n        { internalType: \"uint256\", name: \"lastReturnedIndex\", type: \"uint256\" },\n      ],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n  ];\n\n  try {\n    const locksLength: bigint = await readContract({\n      address: STAKING,\n      abi: stakingAbi,\n      functionName: \"getUserLocksLength\",\n      args: [userAddress],\n      chainId,\n    });\n\n    if (locksLength === 0n) throw new Error(\"No active locks found\");\n\n    const locks = await readContract({\n      address: STAKING,\n      abi: stakingAbi,\n      functionName: \"getLocks\",\n      args: [userAddress, 0, Number(locksLength)],\n      chainId,\n    });\n\n    const unlockableLock = locks.lockData.find(\n      (lock: any) =>\n        !lock.withdrawn &&\n        BigInt(lock.endTime) <= BigInt(Math.floor(Date.now() / 1000))\n    );\n\n    if (!unlockableLock) throw new Error(\"No unlockable lock found\");\n\n    const tx = await writeContract({\n      address: STAKING,\n      abi: stakingAbi,\n      functionName: \"unlock\",\n      args: [unlockableLock.index],\n      chainId,\n    });\n\n    return { success: true, txHash: tx.hash, indexUsed: unlockableLock.index };\n  } catch (err: any) {\n    return { success: false, error: err.message || \"Withdraw failed\" };\n  }\n}",
  "deposit": "export async function deposit(\n  amount: any, address: any, tokenDecimals: any, chainId: any,\n  duration: number = 28,\n  vesting: boolean = false\n) {\n  const STAKING = \"0x7f3E35B41BDF7DBA6a90661918d0EfDDC6C15c3C\"; // replace with actual WINR staking contract\n\n  const stakingAbi = [\n    {\n      name: \"lock\",\n      type: \"function\",\n      stateMutability: \"payable\", // since native WINR is sent\n      inputs: [\n        { name: \"amount\", type: \"uint128\" },\n        { name: \"duration\", type: \"uint16\" },\n        { name: \"vesting\", type: \"bool\" }\n      ],\n      outputs: []\n    }\n  ];\n\n  try {\n    const amountInWei = parseUnits(amount, tokenDecimals);\n\n    const txHash = await writeContractAsync({\n      address: STAKING,\n      abi: stakingAbi,\n      functionName: \"lock\",\n      args: [amountInWei, duration, vesting],\n      chainId,\n      value: amountInWei // send native WINR as msg.value\n    });\n\n    return { success: true, txHash };\n  } catch (err: any) {\n    return { success: false, error: err.message || \"Deposit failed\" };\n  }\n}",
  "underlyingAsset": "",
  "yieldBearingToken": "0x7f3E35B41BDF7DBA6a90661918d0EfDDC6C15c3C",
  "withdrawContract": "",
  "withdrawUri": ""
}]